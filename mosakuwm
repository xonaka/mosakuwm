#!/usr/bin/env python3

import os
import sys
import subprocess
import re
import time
import math
import importlib.util
from pathlib import Path
from Xlib import X, XK, display
from Xlib.ext import randr  # RandR拡張を追加
from threading import Thread
import json

def load_config():
    """設定ファイルを読み込む"""
    # 設定ファイルの検索順序
    config_paths = [
        Path.cwd() / 'config.py',  # カレントディレクトリ
        Path.home() / '.config' / 'mosakuwm' / 'config.py',  # ユーザー設定
    ]

    # デフォルト設定
    class DefaultConfig:
        # アプリケーション設定
        TERMINAL = 'urxvt'
        EDITOR = 'emacs'
        BROWSER = 'google-chrome'
        PRIORITY_WINDOW = EDITOR

        # ウィンドウ設定
        WINDOW_MIN_WIDTH = 1920/8
        WINDOW_MIN_HEIGHT = 1280/8
        INIT_PTR_POS = 30

        # フレーム設定
        FRAME_COLOR = 'SteelBlue3'
        FRAME_SPECIAL_COLOR = 'orange'
        FRAME_THICKNESS = 2

        # 仮想スクリーン設定
        MAX_VSCREEN = 4

        # タイル配置設定
        TILE_RATIOS = {
            'main_pane_ratio': 0.6,
            'grid_main_ratio': 0.5,
            'horizontal_ratios': [0.5],
            'vertical_ratios': [0.5],
        }

        # キーバインド設定
        KEY_BINDS = {}

        # パフォーマンス設定
        DRAG_INTERVAL = 1/60

        # ウィンドウルール設定
        WINDOW_RULES = {}
        WINDOW_POSITIONS = {}

        # レイアウトプリセット設定
        LAYOUT_PRESETS = {}

    config = DefaultConfig

    # 設定ファイルの読み込み
    for config_path in config_paths:
        if config_path.exists():
            try:
                spec = importlib.util.spec_from_file_location("config", config_path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                config = module
                debug(f'設定を読み込みました: {config_path}')
                break
            except Exception as e:
                debug(f'設定の読み込みに失敗しました: {config_path} - {str(e)}')

    return config

def debug(msg):
    """デバッグメッセージを標準エラー出力に出力"""
    print(msg, file=sys.stderr, flush=True)

# 定数定義
LEFT = 1
RIGHT = 2
UPPER = 4
LOWER = 8

# 移動方向の定数
FORWARD = 0
BACKWARD = 1

# タイル配置パターンの定数
TILE_PATTERN_GRID = 0
TILE_PATTERN_HORIZONTAL = 1
TILE_PATTERN_VERTICAL = 2

class WindowAnimation:
    """ウィンドウアニメーションを管理するクラス"""
    def __init__(self, window, start_geom, end_geom, duration=0.3, fps=60):
        self.window = window
        self.start_geom = start_geom
        self.end_geom = end_geom
        self.duration = duration
        self.interval = 1.0 / fps
        self.start_time = None
        
    def start(self):
        """アニメーションを開始"""
        self.start_time = time.time()
        Thread(target=self._animate).start()
        
    def _animate(self):
        """アニメーションのメインループ"""
        while True:
            current_time = time.time()
            progress = (current_time - self.start_time) / self.duration
            
            if progress >= 1:
                # 最終位置に設定
                self.window.configure(
                    x=self.end_geom['x'],
                    y=self.end_geom['y'],
                    width=self.end_geom['width'],
                    height=self.end_geom['height']
                )
                break
                
            # イージング関数を適用（ease-in-out）
            t = progress
            if t < 0.5:
                progress = 2 * t * t
            else:
                t = 2 * t - 1
                progress = -0.5 * (t * (t - 2) - 1)
                
            # 現在の位置とサイズを計算
            current_x = self.start_geom['x'] + (self.end_geom['x'] - self.start_geom['x']) * progress
            current_y = self.start_geom['y'] + (self.end_geom['y'] - self.start_geom['y']) * progress
            current_width = self.start_geom['width'] + (self.end_geom['width'] - self.start_geom['width']) * progress
            current_height = self.start_geom['height'] + (self.end_geom['height'] - self.start_geom['height']) * progress
            
            # ウィンドウを更新
            self.window.configure(
                x=int(current_x),
                y=int(current_y),
                width=int(current_width),
                height=int(current_height)
            )
            
            time.sleep(self.interval)

class PresetManager:
    """レイアウトプリセットを管理するクラス"""
    def __init__(self, wm):
        self.wm = wm
        self.categories = {
            'coding': '開発環境',
            'web': 'ウェブ作業',
            'office': 'オフィス作業',
            'media': 'メディア',
            'custom': 'カスタム'
        }
        self.load_preset_metadata()

    def load_preset_metadata(self):
        """プリセットのメタデータを読み込み"""
        self.metadata = {}
        metadata_path = Path.home() / '.config' / 'mosakuwm' / 'preset_metadata.json'
        
        if metadata_path.exists():
            try:
                with open(metadata_path, 'r') as f:
                    self.metadata = json.load(f)
            except json.JSONDecodeError:
                debug('Invalid metadata file')
        
        # メタデータの初期化
        for name in self.wm.config.LAYOUT_PRESETS:
            if name not in self.metadata:
                self.metadata[name] = {
                    'category': 'custom',
                    'priority': 0,
                    'auto_rules': []
                }

    def save_preset_metadata(self):
        """プリセットのメタデータを保存"""
        metadata_path = Path.home() / '.config' / 'mosakuwm' / 'preset_metadata.json'
        with open(metadata_path, 'w') as f:
            json.dump(self.metadata, f, indent=4, ensure_ascii=False)

    def search_presets(self, query):
        """プリセットを検索"""
        results = []
        query = query.lower()
        
        for name, preset in self.wm.config.LAYOUT_PRESETS.items():
            score = 0
            metadata = self.metadata.get(name, {})
            
            # 名前とカテゴリでの検索
            if query in name.lower():
                score += 3
            if query in preset.get('name', '').lower():
                score += 2
            if query in preset.get('description', '').lower():
                score += 1
            if query in self.categories.get(metadata.get('category'), '').lower():
                score += 1
            
            if score > 0:
                results.append({
                    'name': name,
                    'score': score,
                    'priority': metadata.get('priority', 0),
                    'category': metadata.get('category', 'custom')
                })
        
        # スコアと優先度でソート
        results.sort(key=lambda x: (-x['score'], -x['priority']))
        return results

    def set_preset_category(self, preset_name, category):
        """プリセットのカテゴリを設定"""
        if preset_name not in self.metadata:
            self.metadata[preset_name] = {}
        self.metadata[preset_name]['category'] = category
        self.save_preset_metadata()

    def set_preset_priority(self, preset_name, priority):
        """プリセットの優先度を設定"""
        if preset_name not in self.metadata:
            self.metadata[preset_name] = {}
        self.metadata[preset_name]['priority'] = priority
        self.save_preset_metadata()

    def add_auto_rule(self, preset_name, rule):
        """プリセットの自動適用ルールを追加"""
        if preset_name not in self.metadata:
            self.metadata[preset_name] = {}
        if 'auto_rules' not in self.metadata[preset_name]:
            self.metadata[preset_name]['auto_rules'] = []
        self.metadata[preset_name]['auto_rules'].append(rule)
        self.save_preset_metadata()

    def remove_auto_rule(self, preset_name, rule_index):
        """プリセットの自動適用ルールを削除"""
        if (preset_name in self.metadata and
            'auto_rules' in self.metadata[preset_name] and
            0 <= rule_index < len(self.metadata[preset_name]['auto_rules'])):
            del self.metadata[preset_name]['auto_rules'][rule_index]
            self.save_preset_metadata()

    def check_auto_rules(self, window_class, monitor_name=None, time_range=None):
        """自動適用ルールをチェック"""
        best_preset = None
        max_priority = -1
        
        for preset_name, metadata in self.metadata.items():
            if preset_name not in self.wm.config.LAYOUT_PRESETS:
                continue
                
            for rule in metadata.get('auto_rules', []):
                if self._match_rule(rule, window_class, monitor_name, time_range):
                    priority = metadata.get('priority', 0)
                    if priority > max_priority:
                        max_priority = priority
                        best_preset = preset_name
        
        return best_preset

    def _match_rule(self, rule, window_class, monitor_name, time_range):
        """ルールがマッチするかチェック"""
        if 'window_class' in rule and rule['window_class'] != window_class:
            return False
            
        if 'monitor' in rule and monitor_name and rule['monitor'] != monitor_name:
            return False
            
        if 'time_range' in rule and time_range:
            start, end = rule['time_range']
            if not (start <= time_range <= end):
                return False
                
        return True

class MonitorManager:
    """モニター管理を行うクラス"""
    def __init__(self, wm):
        self.wm = wm
        self.monitors = {}
        self.monitor_configs = {}
        self.load_monitor_configs()
        
    def load_monitor_configs(self):
        """モニター設定を読み込み"""
        config_dir = self.wm.ensure_config_dir()
        config_file = config_dir / 'monitor_config.json'
        
        if config_file.exists():
            try:
                with open(config_file, 'r') as f:
                    self.monitor_configs = json.load(f)
            except json.JSONDecodeError:
                debug('Invalid monitor config file')
                
    def save_monitor_configs(self):
        """モニター設定を保存"""
        config_dir = self.wm.ensure_config_dir()
        config_file = config_dir / 'monitor_config.json'
        
        with open(config_file, 'w') as f:
            json.dump(self.monitor_configs, f, indent=4)
            
    def update_monitors(self):
        """モニター情報を更新"""
        old_monitors = self.monitors.copy()
        self.monitors = self.wm.get_monitors_info()
        
        # 新しく接続されたモニターを検出
        for name, monitor in self.monitors.items():
            if monitor['connected'] and (name not in old_monitors or not old_monitors[name]['connected']):
                self.handle_monitor_connected(name, monitor)
                
        # 切断されたモニターを検出
        for name, monitor in old_monitors.items():
            if monitor['connected'] and (name not in self.monitors or not self.monitors[name]['connected']):
                self.handle_monitor_disconnected(name)
                
    def handle_monitor_connected(self, name, monitor):
        """モニター接続時の処理"""
        debug(f'Monitor connected: {name}')
        
        # 保存された設定を適用
        if name in self.monitor_configs:
            config = self.monitor_configs[name]
            
            # レイアウトプリセットの適用
            if 'layout_preset' in config:
                self.wm.apply_layout_preset(config['layout_preset'])
                
            # ウィンドウの再配置
            if 'window_positions' in config:
                for window_class, pos in config['window_positions'].items():
                    for window in self.wm.exposed_windows:
                        if self.wm.get_window_class(window) == window_class:
                            window.configure(
                                x=pos['x'] + monitor['geometry']['x'],
                                y=pos['y'] + monitor['geometry']['y']
                            )
                            
    def handle_monitor_disconnected(self, name):
        """モニター切断時の処理"""
        debug(f'Monitor disconnected: {name}')
        
        # 現在のウィンドウ配置を保存
        if name not in self.monitor_configs:
            self.monitor_configs[name] = {}
            
        config = self.monitor_configs[name]
        config['window_positions'] = {}
        
        for window in self.wm.exposed_windows:
            if self.wm.managed_windows.get(window, {}).get('name') == name:
                geom = self.wm.get_window_geometry(window)
                if geom:
                    window_class = self.wm.get_window_class(window)
                    config['window_positions'][window_class] = {
                        'x': geom.x - self.monitors[name]['geometry']['x'],
                        'y': geom.y - self.monitors[name]['geometry']['y']
                    }
                    
        self.save_monitor_configs()
        
        # ウィンドウをプライマリモニターに移動
        primary = self.get_primary_monitor()
        if primary and primary['name'] != name:
            for window in self.wm.exposed_windows:
                if self.wm.managed_windows.get(window, {}).get('name') == name:
                    self.wm.move_window_to_monitor(window, primary)
                    
    def get_primary_monitor(self):
        """プライマリモニターを取得"""
        for name, monitor in self.monitors.items():
            if monitor['connected'] and monitor['primary']:
                monitor['name'] = name
                return monitor
        return None
        
    def set_monitor_layout_preset(self, monitor_name, preset_name):
        """モニターのデフォルトレイアウトプリセットを設定"""
        if monitor_name not in self.monitor_configs:
            self.monitor_configs[monitor_name] = {}
        self.monitor_configs[monitor_name]['layout_preset'] = preset_name
        self.save_monitor_configs()

class Mosakuwm:
    def __init__(self):
        """初期化"""
        try:
            self.display = display.Display()
            self.screen = self.display.screen()
            
            # RandR拡張を有効化
            try:
                self.display.xrandr_query_version()
            except Exception as e:
                print(f"警告: RandR拡張の初期化に失敗しました: {e}")
            
            # 他のウィンドウマネージャーが実行中かチェック
            try:
                self.screen.root.change_attributes(
                    event_mask = X.SubstructureRedirectMask
                )
            except Exception as e:
                print("エラー: 他のウィンドウマネージャーが実行中です")
                print("ヒント: 既存のウィンドウマネージャーを終了してから再試行してください")
                sys.exit(1)
            
            # 通常の初期化を続行
            self.screen.root.change_attributes(
                event_mask = X.SubstructureRedirectMask |
                X.SubstructureNotifyMask |
                X.EnterWindowMask |
                X.LeaveWindowMask |
                X.FocusChangeMask |
                X.ButtonPressMask |
                X.ButtonReleaseMask |
                X.PointerMotionMask |
                randr.RRScreenChangeNotifyMask
            )
            
            # 残りの初期化処理
            self.colormap = self.screen.default_colormap
            
            # 設定の読み込み
            self.config = load_config()
            
            # キーバインド関連
            self.keybinds = {}
            self.pressed_keys = set()
            
            # ウィンドウ管理用の辞書とリスト
            self.managed_windows = {}
            self.exposed_windows = []
            self.framed_window = None
            
            # フレーム関連
            self.frame_windows = {}
            self.special_window = []
            
            # 仮想スクリーン関連
            self.window_vscreen = {}
            self.current_vscreen = 0
            
            # ドラッグ操作用の変数
            self.start = None
            self.start_geom = None
            self.last_dragged_time = time.time()
            
            # モニター情報の初期化
            self.monitor_geometries = self.get_available_monitor_geometries()
            self.maxsize = self.get_screen_size()
            
            # フレームウィンドウの作成
            self.create_frame_windows()
            
            # イベントの捕捉を開始
            self.catch_events()
            self.grab_buttons()
            self.grab_keys()
            
            # 既存のウィンドウを管理対象に追加
            for child in self.screen.root.query_tree().children:
                if child.get_attributes().map_state:
                    self.manage_window(child)
            
            # タイル配置関連
            self.current_main_ratio = self.config.TILE_RATIOS['main_pane_ratio']
            self.current_tile_pattern = TILE_PATTERN_GRID
            
            # ウィンドウルール関連
            self.floating_windows = set()  # フローティングウィンドウを保持
            
            # レイアウト関連
            self.current_layout = None
            self.layout_windows = {}  # レイアウトに属するウィンドウを保持

            # プリセットマネージャーの初期化
            self.preset_manager = PresetManager(self)
            
            # モニターマネージャーの初期化
            self.monitor_manager = MonitorManager(self)
        except Exception as e:
            print(f"初期化中にエラーが発生しました: {e}")
            sys.exit(1)

    def get_screen_size(self):
        """スクリーン全体のサイズを取得"""
        lines = subprocess.getoutput('xrandr').split('\n')
        match = re.search(r'current (\d+) x (\d+)', lines[0])
        return {
            'width': int(match.group(1)),
            'height': int(match.group(2))
        }

    def get_available_monitor_geometries(self):
        """利用可能なモニターの情報を取得"""
        debug('function: get_available_monitor_geometries called')
        monitors = self.get_monitors_info()
        geometries = {}
        for name, monitor in monitors.items():
            if monitor['connected']:
                geom = monitor['geometry']
                if not geom:
                    debug(f'Monitor {name} is connected but not mapped.')
                    continue
                geometries[name] = {
                    'name': name,
                    'width': geom['width'],
                    'height': geom['height'],
                    'x': geom['x'],
                    'y': geom['y']
                }
        return geometries

    def get_monitors_info(self):
        """xrandrを使用して接続されているモニターの情報を取得"""
        debug('function: get_monitors_info called')
        lines = subprocess.getoutput('xrandr').split('\n')
        monitors = {}
        for line in lines[1:]:
            if 'connected' in line:
                name = line.split()[0]
                connected = ' connected' in line
                try:
                    m = re.search(r'(\d+)x(\d+)\+(\d+)\+(\d+)', line)
                    width = int(m.group(1))
                    height = int(m.group(2))
                    x = int(m.group(3))
                    y = int(m.group(4))
                    geom = {
                        'width': width,
                        'height': height,
                        'x': x,
                        'y': y
                    }
                except:
                    geom = None
                primary = 'primary' in line
                monitors[name] = {
                    'connected': connected,
                    'geometry': geom,
                    'primary': primary
                }
        return monitors

    def get_monitor_coverarea(self, wgeom, mgeom):
        """ウィンドウとモニターの重なり面積を計算"""
        xmin = min(wgeom.x, mgeom['x'])
        xmax = max(wgeom.x + wgeom.width, mgeom['x'] + mgeom['width'])
        xsum = wgeom.width + mgeom['width']
        xcover = max(0, xsum - (xmax - xmin))
        
        ymin = min(wgeom.y, mgeom['y'])
        ymax = max(wgeom.y + wgeom.height, mgeom['y'] + mgeom['height'])
        ysum = wgeom.height + mgeom['height']
        ycover = max(0, ysum - (ymax - ymin))
        
        return xcover * ycover

    def get_monitor_geometry_with_window(self, window):
        """ウィンドウが最も重なっているモニターのジオメトリを取得"""
        geom = self.get_window_geometry(window)
        if not geom:
            return list(self.monitor_geometries.values())[0]

        maxcoverage = 0
        maxmonitor = list(self.monitor_geometries.values())[0]
        
        for name, monitor in self.monitor_geometries.items():
            coverarea = self.get_monitor_coverarea(geom, monitor)
            coverage = coverarea / (monitor['width'] * monitor['height'])
            normcoverage = coverarea * coverage
            if maxcoverage < normcoverage:
                maxcoverage = normcoverage
                maxmonitor = monitor
        
        return maxmonitor

    def move_window_to_monitor(self, window, dst):
        """ウィンドウを指定したモニターに移動"""
        if window not in self.managed_windows.keys():
            return
            
        src = self.managed_windows.get(window, None)
        if src is None:
            return
            
        wgeom = self.get_window_geometry(window)
        if wgeom is None:
            return
            
        # 移動先モニターのサイズに合わせてウィンドウをスケーリング
        hratio = dst['width'] / src['width']
        vratio = dst['height'] / src['height']
        
        xd = wgeom.x - src['x']
        yd = wgeom.y - src['y']
        
        x = int(xd * hratio) + dst['x']
        y = int(yd * vratio) + dst['y']
        width = int(wgeom.width * hratio)
        height = int(wgeom.height * vratio)
        
        window.configure(
            x=x,
            y=y,
            width=width,
            height=height
        )
        self.managed_windows[window] = dst

    def move_window_to_next_monitor(self, window):
        """ウィンドウを次のモニターに移動"""
        if window not in self.exposed_windows:
            return
            
        src = self.managed_windows.get(window, None)
        if src is None:
            return
            
        monitors = list(self.monitor_geometries.values())
        srcidx = monitors.index(src)
        dstidx = (srcidx + 1) % len(monitors)
        dst = monitors[dstidx]
        
        self.move_window_to_monitor(window, dst)

    def catch_events(self):
        """ルートウィンドウのイベントをキャッチするための設定"""
        self.screen.root.change_attributes(
            event_mask = X.SubstructureRedirectMask |
            X.SubstructureNotifyMask |
            X.EnterWindowMask |
            X.LeaveWindowMask |
            X.FocusChangeMask |
            X.ButtonPressMask |
            X.ButtonReleaseMask |
            X.PointerMotionMask |
            randr.RRScreenChangeNotifyMask  # 既に修正済み
        )

    def grab_buttons(self):
        """マウスボタンのグラブ設定"""
        debug('function: grab_buttons called')
        # Alt + 左クリックでウィンドウ移動
        # Alt + 右クリックでウィンドウリサイズ
        for button in [1, 3]:  # 1: 左クリック, 3: 右クリック
            self.screen.root.grab_button(
                button,
                X.Mod1Mask,  # Alt キー
                True,
                X.ButtonPressMask |
                X.ButtonReleaseMask |
                X.PointerMotionMask,
                X.GrabModeAsync,
                X.GrabModeAsync,
                X.NONE,
                X.NONE)

    def grab_keys(self):
        """キーバインドの設定"""
        debug('function: grab_keys called')
        for (key, modifier), rule in self.config.KEY_BINDS.items():
            keysym = XK.string_to_keysym(key)
            keycode = self.display.keysym_to_keycode(keysym)
            if modifier is None:
                continue
            self.screen.root.grab_key(
                keycode,
                modifier,
                True,
                X.GrabModeAsync,
                X.GrabModeAsync
            )
            self.keybinds[(keycode, modifier)] = rule
            debug(f'debug: ({key}, {modifier}) grabbed as ({keycode}, {modifier})')

    def handle_button_press(self, event):
        """マウスボタンが押された時の処理"""
        debug('handler: handle_button_press called')
        window = event.child
        if window not in self.managed_windows.keys():
            return

        # ポインタをグラブしてドラッグ操作の準備
        self.screen.root.grab_pointer(
            True,
            X.PointerMotionMask |
            X.ButtonReleaseMask,
            X.GrabModeAsync,
            X.GrabModeAsync,
            X.NONE,
            X.NONE,
            0)

        self.start = event
        self.start_geom = self.get_window_geometry(window)

    def handle_button_release(self, event):
        """マウスボタンが離された時の処理"""
        debug('handler: handle_button_release called')
        self.display.ungrab_pointer(0)
        if event.child in self.managed_windows:
            # ウィンドウの所属モニターを更新
            self.managed_windows[event.child] = self.get_monitor_geometry_with_window(event.child)

    def handle_motion_notify(self, event):
        """マウスポインタが移動した時の処理"""
        debug('handler: handle_motion_notify called')
        if self.start is None or self.start.child == X.NONE:
            return

        # ドラッグ更新の間隔制御
        now = time.time()
        if now - self.last_dragged_time < self.config.DRAG_INTERVAL:
            return
        self.last_dragged_time = now

        # マウスの移動量を計算
        xdiff = event.root_x - self.start.root_x
        ydiff = event.root_y - self.start.root_y

        if self.start.detail == 1:  # 左クリックドラッグ: 移動
            self.start.child.configure(
                x=self.start_geom.x + xdiff,
                y=self.start_geom.y + ydiff
            )
            self.draw_frame_windows()  # フレームも一緒に移動
        elif self.start.detail == 3:  # 右クリックドラッグ: リサイズ
            # 最小サイズのチェック
            new_width = self.start_geom.width + xdiff
            new_height = self.start_geom.height + ydiff
            
            if new_width <= self.config.WINDOW_MIN_WIDTH or new_height <= self.config.WINDOW_MIN_HEIGHT:
                return
                
            self.start.child.configure(
                width=new_width,
                height=new_height
            )
            self.draw_frame_windows()  # フレームもリサイズ

    def manage_window(self, window):
        """新しいウィンドウを管理対象に追加（自動ルール対応）"""
        attrs = self.get_window_attributes(window)
        if window in self.managed_windows.keys():
            return
        if attrs is None:
            return
        if attrs.override_redirect:
            return
            
        self.managed_windows[window] = self.get_monitor_geometry_with_window(window)
        self.exposed_windows.append(window)
        self.window_vscreen[window] = self.current_vscreen
        
        # ウィンドウルールの適用
        self.apply_window_rules(window)
        
        # レイアウトの適用
        self.apply_layout(window)  # apply_layout_to_windowをapply_layoutに変更
        
        # 自動ルールのチェック
        window_class = self.get_window_class(window)
        monitor = self.managed_windows.get(window)
        monitor_name = next((name for name, geom in self.monitor_geometries.items()
                            if geom == monitor), None)
        
        from datetime import datetime
        current_time = datetime.now().strftime('%H:%M')
        
        preset_name = self.preset_manager.check_auto_rules(
            window_class, monitor_name, current_time)
        
        if preset_name:
            self.apply_layout_preset(preset_name)
        
        window.map()

    def get_window_attributes(self, window):
        """ウィンドウの属性を取得"""
        try:
            return window.get_attributes()
        except:
            return None

    def get_window_geometry(self, window):
        """ウィンドウのジオメトリを取得"""
        try:
            return window.get_geometry()
        except:
            return None

    def handle_key_press(self, event):
        """キーが押された時の処理"""
        debug('handler: handle_key_press called')
        keycode = event.detail
        modifier = event.state
        entry = (keycode, modifier)
        
        rule = self.keybinds.get(entry, None)
        if rule:
            if 'method' in rule:
                method = getattr(self, rule['method'], None)
                if method:
                    arg = rule.get('arg', None)
                    if arg is not None:
                        method(event, arg)
                    else:
                        method(event)
            elif 'command' in rule:
                os.system(rule['command'])

    def cb_focus_next_window(self, event, direction=FORWARD):
        """次のウィンドウにフォーカスを移動"""
        debug('callback: cb_focus_next_window called')
        if not self.exposed_windows:
            return
            
        if self.framed_window in self.exposed_windows:
            idx = self.exposed_windows.index(self.framed_window)
            if direction == FORWARD:
                idx = (idx + 1) % len(self.exposed_windows)
            else:
                idx = (idx - 1) % len(self.exposed_windows)
        else:
            idx = 0
            
        next_window = self.exposed_windows[idx]
        self.focus_window(next_window)
        next_window.warp_pointer(self.config.INIT_PTR_POS, self.config.INIT_PTR_POS)

    def focus_window(self, window):
        """指定したウィンドウにフォーカスを設定"""
        debug('function: focus_window called')
        if window not in self.exposed_windows:
            return
            
        window.set_input_focus(X.RevertToParent, 0)
        window.configure(stack_mode=X.Above)
        self.framed_window = window
        self.draw_frame_windows()

    def cb_halve_window(self, event, direction):
        """ウィンドウを半分のサイズに変更"""
        debug('callback: cb_halve_window called')
        if not self.framed_window:
            return
            
        self.halve_window(self.framed_window, direction)
        self.framed_window.warp_pointer(self.config.INIT_PTR_POS, self.config.INIT_PTR_POS)

    def halve_window(self, window, direction):
        """ウィンドウを指定した方向に半分のサイズにする"""
        if window not in self.exposed_windows:
            return
            
        geom = self.get_window_geometry(window)
        if not geom:
            return
            
        if direction & (LEFT | RIGHT) != 0 and geom.width <= self.config.WINDOW_MIN_WIDTH:
            return
        if direction & (UPPER | LOWER) != 0 and geom.height <= self.config.WINDOW_MIN_HEIGHT:
            return
            
        x, y = geom.x, geom.y
        width, height = geom.width, geom.height
        
        if direction & (LEFT | RIGHT) != 0:
            width //= 2
        if direction & (UPPER | LOWER) != 0:
            height //= 2
            
        if direction & RIGHT != 0:
            x += width
        if direction & LOWER != 0:
            y += height
            
        window.configure(
            x=x,
            y=y,
            width=width,
            height=height
        )

    def cb_move_window_to_next_monitor(self, event):
        """ウィンドウを次のモニターに移動"""
        debug('callback: cb_move_window_to_next_monitor called')
        if not self.framed_window:
            return
            
        self.move_window_to_next_monitor(self.framed_window)
        self.framed_window.warp_pointer(self.config.INIT_PTR_POS, self.config.INIT_PTR_POS)

    def loop(self):
        """メインイベントループ"""
        while True:
            event = self.display.next_event()
            if event.type == X.MapRequest:
                self.handle_map_request(event)
            elif event.type == X.DestroyNotify:
                self.handle_destroy_notify(event)
            elif event.type == X.ButtonPress:
                self.handle_button_press(event)
            elif event.type == X.ButtonRelease:
                self.handle_button_release(event)
            elif event.type == X.MotionNotify:
                self.handle_motion_notify(event)
            elif event.type == X.KeyPress:
                self.handle_key_press(event)
            # XRandRのイベント処理を修正
            try:
                if hasattr(self.display.extension_event, 'RRScreenChangeNotify') and \
                   event.type == self.display.extension_event.RRScreenChangeNotify:
                    self.handle_randr_notify(event)
            except AttributeError:
                pass  # XRandR拡張が利用できない場合は無視

    def handle_map_request(self, event):
        """新しいウィンドウが作成された時のハンドラ"""
        self.manage_window(event.window)

    def handle_destroy_notify(self, event):
        """ウィンドウが破棄された時のハンドラ"""
        if event.window in self.managed_windows:
            self.managed_windows.pop(event.window)
            if event.window in self.exposed_windows:
                self.exposed_windows.remove(event.window)
            if event.window in self.window_vscreen:
                self.window_vscreen.pop(event.window)
            if event.window == self.framed_window:
                self.framed_window = None
                self.unmap_frame_windows()

    def select_vscreen(self, num):
        """指定した仮想スクリーンに切り替え"""
        debug('function: select_vscreen called')
        if num < 0 or num >= self.config.MAX_VSCREEN:
            return

        self.current_vscreen = num
        self.exposed_windows = []

        # 現在の仮想スクリーンに属するウィンドウのみを表示
        for window in self.managed_windows.keys():
            if self.window_vscreen[window] == num:
                window.map()
                self.exposed_windows.append(window)
            else:
                window.unmap()

    def send_window_to_next_vscreen(self, window, direction):
        """ウィンドウを次または前の仮想スクリーンに移動"""
        debug('function: send_window_to_next_vscreen called')
        if window not in self.exposed_windows:
            return None

        current_idx = self.window_vscreen[window]
        if direction == FORWARD:
            next_idx = (current_idx + 1) % self.config.MAX_VSCREEN
        else:
            next_idx = (current_idx - 1) % self.config.MAX_VSCREEN

        self.window_vscreen[window] = next_idx
        return next_idx

    def create_frame_windows(self):
        """フレームウィンドウの作成"""
        debug('function: create_frame_windows called')
        self.frame_pixel = self.colormap.alloc_named_color(self.config.FRAME_COLOR).pixel
        
        for side in ['left', 'right', 'upper', 'lower']:
            window = self.screen.root.create_window(
                0, 0, 16, 16, 0,
                self.screen.root_depth,
                X.InputOutput,
                background_pixel=self.frame_pixel,
                override_redirect=True
            )
            window.map()
            self.frame_windows[side] = window

    def draw_frame_windows(self):
        """フレームウィンドウの描画"""
        if self.framed_window is None:
            return

        # フレームの色を設定
        if self.framed_window in self.special_window:
            new_frame_pixel = self.colormap.alloc_named_color(self.config.FRAME_SPECIAL_COLOR).pixel
        else:
            new_frame_pixel = self.colormap.alloc_named_color(self.config.FRAME_COLOR).pixel

        # 各フレームの色を更新
        for side in ['left', 'right', 'upper', 'lower']:
            self.frame_windows[side].change_attributes(background_pixel=new_frame_pixel)
            self.frame_windows[side].clear_area(0, 0, 0, 0, True)

        # フレームの位置とサイズを設定
        geom = self.get_window_geometry(self.framed_window)
        if geom is None:
            return

        for side in ['left', 'right', 'upper', 'lower']:
            x, y, width, height = 0, 0, 0, 0
            if side == 'left':
                x = geom.x
                y = geom.y
                width = self.config.FRAME_THICKNESS
                height = geom.height
            elif side == 'right':
                x = geom.x + geom.width - self.config.FRAME_THICKNESS
                y = geom.y
                width = self.config.FRAME_THICKNESS
                height = geom.height
            elif side == 'upper':
                x = geom.x
                y = geom.y
                width = geom.width
                height = self.config.FRAME_THICKNESS
            elif side == 'lower':
                x = geom.x
                y = geom.y + geom.height - self.config.FRAME_THICKNESS
                width = geom.width
                height = self.config.FRAME_THICKNESS

            self.frame_windows[side].configure(
                x=x,
                y=y,
                width=width,
                height=height,
                stack_mode=X.Above
            )
            self.frame_windows[side].map()

    def map_frame_windows(self):
        """フレームウィンドウを表示"""
        for side in ['left', 'right', 'upper', 'lower']:
            self.frame_windows[side].map()

    def unmap_frame_windows(self):
        """フレームウィンドウを非表示"""
        for side in ['left', 'right', 'upper', 'lower']:
            self.frame_windows[side].unmap()

    def get_tile_layout(self, tile_num):
        """タイル配置のレイアウトを計算"""
        debug('function: get_tile_layout called')
        tmp = int(math.sqrt(tile_num))
        # (row, col)を返す
        if tmp**2 == tile_num:
            return (tmp, tmp)
        if (tmp+1)*tmp >= tile_num:
            return (tmp, tmp+1)
        return (tmp+1, tmp+1)

    def tile_windows(self, window, pattern=TILE_PATTERN_GRID):
        """ウィンドウをタイル状に配置"""
        debug('function: tile_windows called')
        self.current_tile_pattern = pattern
        
        # 現在のモニターを取得
        monitor = self.managed_windows.get(window, None)
        if monitor is None:
            return

        # 現在のモニターに表示されているウィンドウを収集（フローティング以外）
        target_windows = []
        for win in self.exposed_windows:
            if (monitor == self.managed_windows.get(win, None) and
                win not in self.floating_windows):
                target_windows.append(win)

        # ウィンドウをIDでソート（安定した配置のため）
        def sort_key(window):
            return window.id
        target_windows.sort(key=sort_key)

        # エディタウィンドウを優先的に配置
        eidx = None
        for i in range(len(target_windows)):
            if self.config.PRIORITY_WINDOW in self.get_window_class(target_windows[i]).lower():
                eidx = i

        if pattern == TILE_PATTERN_GRID:
            self.tile_windows_grid(target_windows, monitor, eidx)
        elif pattern == TILE_PATTERN_HORIZONTAL:
            self.tile_windows_horizontal(target_windows, monitor, eidx)
        elif pattern == TILE_PATTERN_VERTICAL:
            self.tile_windows_vertical(target_windows, monitor, eidx)

        # ポインタを移動
        window.warp_pointer(self.config.INIT_PTR_POS, self.config.INIT_PTR_POS)

    def tile_windows_grid(self, target_windows, monitor, eidx):
        """グリッドパターンでウィンドウを配置"""
        if not target_windows:
            return

        # レイアウトの計算
        nrows, ncols = self.get_tile_layout(len(target_windows))
        offcuts_num = nrows*ncols - len(target_windows)

        # エディタウィンドウを左下に配置
        if eidx is not None:
            target_windows[eidx], target_windows[ncols*(nrows-1)-1] = \
                target_windows[ncols*(nrows-1)-1], target_windows[eidx]

        # メインウィンドウ（左下）のサイズを調整
        main_ratio = self.config.TILE_RATIOS['grid_main_ratio']
        main_width = int(monitor['width'] * main_ratio / ncols)
        main_height = int(monitor['height'] * main_ratio / nrows)

        # ウィンドウの配置
        for row in reversed(range(nrows)):
            for col in reversed(range(ncols)):
                if not target_windows:
                    break
                win = target_windows.pop(0)
                
                # 位置とサイズの計算
                x = monitor['x'] + monitor['width']*col//ncols
                width = monitor['width']//ncols
                
                # 下段の空きスペースを利用
                if row == 1 and col < offcuts_num:
                    height = monitor['height']*2//nrows
                    y = monitor['y']
                else:
                    height = monitor['height']//nrows
                    y = monitor['y'] + monitor['height']*row//nrows
                
                # メインウィンドウ（左下）のサイズを調整
                if row == 0 and col == 0:
                    width = main_width
                    height = main_height
                
                # ウィンドウの設定
                win.configure(
                    x=x,
                    y=y,
                    width=width,
                    height=height
                )

    def tile_windows_horizontal(self, target_windows, monitor, eidx):
        """水平分割パターンでウィンドウを配置"""
        if not target_windows:
            return

        # エディタウィンドウを最上部に配置
        if eidx is not None:
            target_windows[eidx], target_windows[0] = \
                target_windows[0], target_windows[eidx]

        num_windows = len(target_windows)
        main_height = int(monitor['height'] * self.current_main_ratio)
        sub_height = (monitor['height'] - main_height) // (num_windows - 1) if num_windows > 1 else 0

        for i, win in enumerate(target_windows):
            # 位置とサイズの計算
            x = monitor['x']
            width = monitor['width']
            
            if i == 0:  # メインペイン
                y = monitor['y']
                height = main_height
            else:  # サブペイン
                y = monitor['y'] + main_height + (i-1) * sub_height
                height = sub_height

            # ウィンドウの設定
            win.configure(
                x=x,
                y=y,
                width=width,
                height=height
            )

    def tile_windows_vertical(self, target_windows, monitor, eidx):
        """垂直分割パターンでウィンドウを配置"""
        if not target_windows:
            return

        # エディタウィンドウを最左部に配置
        if eidx is not None:
            target_windows[eidx], target_windows[0] = \
                target_windows[0], target_windows[eidx]

        num_windows = len(target_windows)
        main_width = int(monitor['width'] * self.current_main_ratio)
        sub_width = (monitor['width'] - main_width) // (num_windows - 1) if num_windows > 1 else 0

        for i, win in enumerate(target_windows):
            # 位置とサイズの計算
            y = monitor['y']
            height = monitor['height']
            
            if i == 0:  # メインペイン
                x = monitor['x']
                width = main_width
            else:  # サブペイン
                x = monitor['x'] + main_width + (i-1) * sub_width
                width = sub_width

            # ウィンドウの設定
            win.configure(
                x=x,
                y=y,
                width=width,
                height=height
            )

    def cb_tile_windows(self, event, pattern=TILE_PATTERN_GRID):
        """タイル配置のコールバック"""
        debug('callback: cb_tile_windows called')
        if not self.framed_window:
            return
        self.tile_windows(self.framed_window, pattern)
        self.focus_window(self.framed_window)

    def get_window_class(self, window):
        """ウィンドウのクラス名を取得"""
        try:
            cmd, cls = window.get_wm_class()
            return cls if cls is not None else ''
        except:
            return ''

    def cb_adjust_main_ratio(self, event, delta):
        """メインペインの比率を調整"""
        debug('callback: cb_adjust_main_ratio called')
        new_ratio = self.current_main_ratio + delta
        if 0.1 <= new_ratio <= 0.9:  # 比率の範囲を制限
            self.current_main_ratio = new_ratio
            if self.framed_window:
                self.tile_windows(self.framed_window, self.current_tile_pattern)

    def cb_reset_main_ratio(self, event):
        """メインペインの比率をリセット"""
        debug('callback: cb_reset_main_ratio called')
        self.current_main_ratio = self.config.TILE_RATIOS['main_pane_ratio']
        if self.framed_window:
            self.tile_windows(self.framed_window, self.current_tile_pattern)

    def reload_config(self):
        """設定を再読み込み"""
        debug('function: reload_config called')
        old_config = self.config
        self.config = load_config()

        # キーバインドの再設定
        self.ungrab_keys()
        self.grab_keys()

        # フレームの再設定
        if (self.config.FRAME_COLOR != old_config.FRAME_COLOR or
            self.config.FRAME_SPECIAL_COLOR != old_config.FRAME_SPECIAL_COLOR or
            self.config.FRAME_THICKNESS != old_config.FRAME_THICKNESS):
            self.recreate_frame_windows()

        # タイル配置の更新
        if self.framed_window:
            self.tile_windows(self.framed_window, self.current_tile_pattern)

    def ungrab_keys(self):
        """キーバインドを解除"""
        debug('function: ungrab_keys called')
        for keycode, modifier in self.keybinds.keys():
            self.screen.root.ungrab_key(keycode, modifier)
        self.keybinds.clear()

    def recreate_frame_windows(self):
        """フレームウィンドウを再作成"""
        debug('function: recreate_frame_windows called')
        # 既存のフレームを削除
        for window in self.frame_windows.values():
            window.destroy()
        self.frame_windows.clear()
        
        # フレームを再作成
        self.create_frame_windows()

    def cb_reload_config(self, event):
        """設定再読み込みのコールバック"""
        debug('callback: cb_reload_config called')
        self.reload_config()

    def apply_window_rules(self, window):
        """ウィンドウルールを適用"""
        debug('function: apply_window_rules called')
        window_class = self.get_window_class(window)
        if not window_class:
            return

        # ウィンドウルールの取得
        rule = self.config.WINDOW_RULES.get(window_class.lower(), {})
        
        # 特別な色の設定
        if rule.get('special_color', False):
            self.special_window.append(window)
        
        # フローティングの設定
        if rule.get('floating', False):
            self.floating_windows.add(window)
        
        # 仮想スクリーンの設定
        if 'vscreen' in rule:
            self.window_vscreen[window] = rule['vscreen']
            if rule['vscreen'] != self.current_vscreen:
                window.unmap()
            else:
                window.map()
        
        # モニターの設定
        if 'monitor' in rule:
            monitor_idx = rule['monitor']
            monitors = list(self.monitor_geometries.values())
            if 0 <= monitor_idx < len(monitors):
                self.managed_windows[window] = monitors[monitor_idx]
        
        # 位置の設定
        if 'position' in rule:
            self.apply_window_position(window, rule['position'])

    def apply_window_position(self, window, position_name):
        """ウィンドウの位置を設定"""
        debug('function: apply_window_position called')
        monitor = self.managed_windows.get(window, None)
        if not monitor or position_name not in self.config.WINDOW_POSITIONS:
            return

        geom = self.get_window_geometry(window)
        if not geom:
            return

        position = self.config.WINDOW_POSITIONS[position_name]
        x = position['x']
        y = position['y']

        # パーセンテージ指定の場合は計算
        if isinstance(x, str) and x.endswith('%'):
            x = monitor['x'] + (monitor['width'] - geom.width) * int(x[:-1]) // 100
        else:
            x = monitor['x'] + (x if x >= 0 else monitor['width'] - geom.width + x)

        if isinstance(y, str) and y.endswith('%'):
            y = monitor['y'] + (monitor['height'] - geom.height) * int(y[:-1]) // 100
        else:
            y = monitor['y'] + (y if y >= 0 else monitor['height'] - geom.height + y)

        window.configure(
            x=x,
            y=y
        )

    def apply_layout_preset(self, preset_name):
        """レイアウトプリセットを適用（アニメーション対応）"""
        debug(f'function: apply_layout_preset called with {preset_name}')
        if preset_name not in self.config.LAYOUT_PRESETS:
            return

        preset = self.config.LAYOUT_PRESETS[preset_name]
        self.current_layout = preset_name
        self.layout_windows.clear()

        # 現在のモニターを取得
        monitor = self.get_primary_monitor()
        if not monitor:
            return

        # プリセットの各ウィンドウを作成または移動
        for window_config in preset['windows']:
            window_class = window_config['class']
            
            # 既存のウィンドウを探す
            existing_window = None
            for window in self.exposed_windows:
                if self.get_window_class(window) == window_class:
                    existing_window = window
                    break
                
            if existing_window:
                # 既存のウィンドウを移動
                x, y, width, height = self.calculate_window_geometry(
                    window_config, monitor)
                self.animate_window_move(existing_window, {
                    'x': x,
                    'y': y,
                    'width': width,
                    'height': height
                })
            else:
                # 新しいウィンドウを作成
                command = self.get_command_for_class(window_class)
                if command:
                    os.system(f'{command} &')

    def animate_window_move(self, window, end_geom):
        """ウィンドウの移動をアニメーション化"""
        start_geom = self.get_window_geometry(window)
        if not start_geom:
            return
        
        # 現在の位置とサイズを辞書形式に変換
        start_geom = {
            'x': start_geom.x,
            'y': start_geom.y,
            'width': start_geom.width,
            'height': start_geom.height
        }
        
        # アニメーションを開始
        animation = WindowAnimation(window, start_geom, end_geom)
        animation.start()

    def get_primary_monitor(self):
        """プライマリモニターを取得"""
        for monitor in self.monitor_geometries.values():
            if monitor.get('primary', False):
                return monitor
        return list(self.monitor_geometries.values())[0] if self.monitor_geometries else None

    def get_command_for_class(self, window_class):
        """ウィンドウクラスに対応するコマンドを取得"""
        class_to_command = {
            'urxvt': self.config.TERMINAL,
            'emacs': self.config.EDITOR,
            'google-chrome': self.config.BROWSER
        }
        return class_to_command.get(window_class)

    def calculate_window_geometry(self, window_config, monitor):
        """ウィンドウの位置とサイズを計算"""
        position = window_config['position']
        ratio = window_config.get('ratio', 1.0)
        split = window_config.get('split', 'horizontal')

        # 基本サイズの計算
        if split == 'vertical':
            width = int(monitor['width'] * ratio)
            height = monitor['height']
        else:
            width = monitor['width']
            height = int(monitor['height'] * ratio)

        # 位置の計算
        if position == 'left':
            x = monitor['x']
            y = monitor['y']
        elif position == 'right':
            x = monitor['x'] + monitor['width'] - width
            y = monitor['y']
        elif position == 'top':
            x = monitor['x']
            y = monitor['y']
        elif position == 'bottom':
            x = monitor['x']
            y = monitor['y'] + monitor['height'] - height
        elif position == 'top_left':
            x = monitor['x']
            y = monitor['y']
        elif position == 'top_right':
            x = monitor['x'] + monitor['width'] - width
            y = monitor['y']
        elif position == 'bottom_left':
            x = monitor['x']
            y = monitor['y'] + monitor['height'] - height
        elif position == 'bottom_right':
            x = monitor['x'] + monitor['width'] - width
            y = monitor['y'] + monitor['height'] - height
        else:  # center
            x = monitor['x'] + (monitor['width'] - width) // 2
            y = monitor['y'] + (monitor['height'] - height) // 2

        return x, y, width, height

    def cb_apply_layout_preset(self, event, preset_name):
        """レイアウトプリセット適用のコールバック"""
        debug('callback: cb_apply_layout_preset called')
        self.apply_layout_preset(preset_name)

    def ensure_config_dir(self):
        """設定ディレクトリの存在を確認し、必要に応じて作成"""
        config_dir = Path.home() / '.config' / 'mosakuwm'
        if not config_dir.exists():
            config_dir.mkdir(parents=True)
        return config_dir

    def save_layout_preset(self):
        """現在のレイアウトをプリセットとして保存"""
        debug('function: save_layout_preset called')
        
        # 現在のウィンドウ情報を収集
        windows_info = []
        for window in self.exposed_windows:
            if window in self.floating_windows:
                continue
            
            window_class = self.get_window_class(window)
            if not window_class:
                continue
            
            geom = self.get_window_geometry(window)
            if not geom:
                continue
            
            # モニター情報を取得
            monitor = self.managed_windows.get(window)
            if not monitor:
                continue
            
            # ウィンドウの相対位置とサイズを計算
            rel_x = (geom.x - monitor['x']) / monitor['width']
            rel_y = (geom.y - monitor['y']) / monitor['height']
            rel_width = geom.width / monitor['width']
            rel_height = geom.height / monitor['height']
            
            # 位置の特定
            position = 'custom'
            if rel_x == 0 and rel_y == 0:
                if rel_width == 1 and rel_height == 1:
                    position = 'full'
                elif rel_width < 1 and rel_height == 1:
                    position = 'left'
                elif rel_height < 1:
                    position = 'top_left'
            elif rel_x + rel_width == 1 and rel_y == 0:
                if rel_height == 1:
                    position = 'right'
                else:
                    position = 'top_right'
            elif rel_x == 0 and rel_y + rel_height == 1:
                position = 'bottom_left'
            elif rel_x + rel_width == 1 and rel_y + rel_height == 1:
                position = 'bottom_right'
            
            # 分割方向の特定
            split = 'horizontal'
            if rel_width < 1 and rel_height == 1:
                split = 'vertical'
            
            windows_info.append({
                'class': window_class,
                'ratio': max(rel_width, rel_height),
                'position': position,
                'split': split
            })
        
        if not windows_info:
            debug('No windows to save')
            return
        
        # プリセット名を生成（現在の日時を使用）
        from datetime import datetime
        preset_name = f'layout_{datetime.now().strftime("%Y%m%d_%H%M%S")}'
        
        # プリセットを作成
        new_preset = {
            'name': preset_name,
            'description': f'保存されたレイアウト ({len(windows_info)}ウィンドウ)',
            'windows': windows_info
        }
        
        # 設定ファイルを読み込み
        config_dir = self.ensure_config_dir()
        config_file = config_dir / 'config.py'
        
        if not config_file.exists():
            # 新しい設定ファイルを作成
            config_content = f'''#!/usr/bin/env python3
from Xlib import X

# レイアウトプリセット設定
LAYOUT_PRESETS = {{
    '{preset_name}': {new_preset}
}}
'''
        else:
            # 既存の設定ファイルを読み込み
            with open(config_file, 'r') as f:
                config_content = f.read()
            
            # LAYOUT_PRESETSが存在するか確認
            if 'LAYOUT_PRESETS = {' in config_content:
                # 既存のプリセットに新しいプリセットを追加
                insert_pos = config_content.find('LAYOUT_PRESETS = {') + len('LAYOUT_PRESETS = {')
                config_content = (
                    config_content[:insert_pos] + f"\n    '{preset_name}': {new_preset}," +
                    config_content[insert_pos:]
                )
            else:
                # LAYOUT_PRESETSを新規作成
                config_content += f'''
# レイアウトプリセット設定
LAYOUT_PRESETS = {{
    '{preset_name}': {new_preset}
}}
'''
        
        # 設定ファイルを保存
        with open(config_file, 'w') as f:
            f.write(config_content)
        
        debug(f'Layout preset saved as {preset_name}')
        
        # 設定を再読み込み
        self.reload_config()

    def cb_save_layout_preset(self, event):
        """現在のレイアウトをプリセットとして保存するコールバック"""
        debug('callback: cb_save_layout_preset called')
        self.save_layout_preset()

    def edit_layout_preset(self, preset_name=None, new_name=None, new_description=None):
        """レイアウトプリセットを編集"""
        debug('function: edit_layout_preset called')
        
        if not preset_name and not self.current_layout:
            debug('No preset selected')
            return
        
        preset_name = preset_name or self.current_layout
        if preset_name not in self.config.LAYOUT_PRESETS:
            debug(f'Preset {preset_name} not found')
            return
        
        # 設定ファイルを読み込み
        config_dir = self.ensure_config_dir()
        config_file = config_dir / 'config.py'
        
        if not config_file.exists():
            debug('Config file not found')
            return
        
        with open(config_file, 'r') as f:
            config_content = f.read()
        
        # プリセットの開始位置を検索
        preset_start = config_content.find(f"'{preset_name}': {{")
        if preset_start == -1:
            debug(f'Preset {preset_name} not found in config file')
            return
        
        # プリセットの終了位置を検索（次のプリセットの開始位置まで）
        preset_end = config_content.find("',", preset_start)
        if preset_end == -1:
            preset_end = config_content.find('}', preset_start)
            preset_end = config_content.find('}', preset_end + 1) + 1
        else:
            preset_end = config_content.find('}', preset_start) + 1
        
        # 現在のプリセットを取得
        current_preset = self.config.LAYOUT_PRESETS[preset_name].copy()
        
        # プリセットを更新
        if new_name:
            current_preset['name'] = new_name
        if new_description:
            current_preset['description'] = new_description
        
        # 設定ファイルを更新
        if new_name and new_name != preset_name:
            # 新しい名前でプリセットを追加
            new_preset_str = f"    '{new_name}': {current_preset},\n"
            insert_pos = config_content.find('LAYOUT_PRESETS = {') + len('LAYOUT_PRESETS = {')
            config_content = (
                config_content[:insert_pos] + '\n' + new_preset_str +
                config_content[insert_pos:]
            )
            
            # 古いプリセットを削除
            config_content = (
                config_content[:preset_start] +
                config_content[preset_end + 1:]
            )
        else:
            # プリセットを更新
            new_preset_str = f"    '{preset_name}': {current_preset}"
            config_content = (
                config_content[:preset_start] +
                new_preset_str +
                config_content[preset_end:]
            )
        
        # 設定ファイルを保存
        with open(config_file, 'w') as f:
            f.write(config_content)
        
        debug(f'Layout preset {preset_name} updated')
        
        # 設定を再読み込み
        self.reload_config()

    def delete_layout_preset(self, preset_name=None):
        """レイアウトプリセットを削除"""
        debug('function: delete_layout_preset called')
        
        if not preset_name and not self.current_layout:
            debug('No preset selected')
            return
        
        preset_name = preset_name or self.current_layout
        if preset_name not in self.config.LAYOUT_PRESETS:
            debug(f'Preset {preset_name} not found')
            return
        
        # 設定ファイルを読み込み
        config_dir = self.ensure_config_dir()
        config_file = config_dir / 'config.py'
        
        if not config_file.exists():
            debug('Config file not found')
            return
        
        with open(config_file, 'r') as f:
            config_content = f.read()
        
        # プリセットの開始位置を検索
        preset_start = config_content.find(f"'{preset_name}': {{")
        if preset_start == -1:
            debug(f'Preset {preset_name} not found in config file')
            return
        
        # プリセットの終了位置を検索
        preset_end = config_content.find("',", preset_start)
        if preset_end == -1:
            preset_end = config_content.find('}', preset_start)
            preset_end = config_content.find('}', preset_end + 1) + 1
        else:
            preset_end = config_content.find('}', preset_start) + 1
        
        # プリセットを削除
        config_content = (
            config_content[:preset_start] +
            config_content[preset_end + 1:]
        )
        
        # 設定ファイルを保存
        with open(config_file, 'w') as f:
            f.write(config_content)
        
        debug(f'Layout preset {preset_name} deleted')
        
        # 現在のレイアウトをクリア（削除されたプリセットの場合）
        if preset_name == self.current_layout:
            self.current_layout = None
        
        # 設定を再読み込み
        self.reload_config()

    def cb_edit_layout_preset(self, event, args=None):
        """レイアウトプリセット編集のコールバック"""
        debug('callback: cb_edit_layout_preset called')
        if not args:
            return
        preset_name, new_name, new_description = args
        self.edit_layout_preset(preset_name, new_name, new_description)

    def cb_delete_layout_preset(self, event, preset_name=None):
        """レイアウトプリセット削除のコールバック"""
        debug('callback: cb_delete_layout_preset called')
        self.delete_layout_preset(preset_name)

    def show_layout_presets(self):
        """レイアウトプリセットの一覧を表示"""
        debug('function: show_layout_presets called')
        
        # プリセット情報を収集
        presets_info = []
        for name, preset in self.config.LAYOUT_PRESETS.items():
            presets_info.append({
                'name': name,
                'display_name': preset.get('name', name),
                'description': preset.get('description', ''),
                'windows': len(preset['windows']),
                'is_current': name == self.current_layout
            })
        
        # プリセット情報を整形
        info_text = "レイアウトプリセット一覧:\n\n"
        for preset in presets_info:
            current_mark = "* " if preset['is_current'] else "  "
            info_text += f"{current_mark}{preset['display_name']} ({preset['name']})\n"
            info_text += f"   説明: {preset['description']}\n"
            info_text += f"   ウィンドウ数: {preset['windows']}\n\n"
        
        # 通知ウィンドウを作成
        notification = self.screen.root.create_window(
            10, 10, 400, 300, 0,
            self.screen.root_depth,
            X.InputOutput,
            background_pixel=self.screen.white_pixel,
            override_redirect=True
        )
        
        # テキストを描画
        gc = notification.create_gc(
            foreground=self.screen.black_pixel,
            background=self.screen.white_pixel
        )
        
        # テキストを行ごとに描画
        y = 10
        for line in info_text.split('\n'):
            notification.draw_text(gc, 10, y, line)
            y += 20
        
        # ウィンドウを表示
        notification.map()
        
        # 3秒後に自動的に閉じる
        def close_notification():
            time.sleep(3)
            notification.destroy()
        
        Thread(target=close_notification).start()

    def cb_show_layout_presets(self, event):
        """レイアウトプリセット一覧表示のコールバック"""
        debug('callback: cb_show_layout_presets called')
        self.show_layout_presets()

    def export_layout_presets(self, export_path=None):
        """レイアウトプリセットをJSONファイルにエクスポート"""
        debug('function: export_layout_presets called')
        
        if not export_path:
            export_path = Path.home() / '.config' / 'mosakuwm' / 'presets.json'
        
        # プリセットをエクスポート用の形式に変換
        presets_data = {}
        for name, preset in self.config.LAYOUT_PRESETS.items():
            presets_data[name] = {
                'name': preset.get('name', name),
                'description': preset.get('description', ''),
                'windows': preset['windows']
            }
        
        # JSONファイルに保存
        with open(export_path, 'w') as f:
            json.dump(presets_data, f, indent=4, ensure_ascii=False)
        
        debug(f'Layout presets exported to {export_path}')

    def import_layout_presets(self, import_path=None):
        """レイアウトプリセットをJSONファイルからインポート"""
        debug('function: import_layout_presets called')
        
        if not import_path:
            import_path = Path.home() / '.config' / 'mosakuwm' / 'presets.json'
        
        if not import_path.exists():
            debug(f'Import file not found: {import_path}')
            return
        
        # JSONファイルを読み込み
        try:
            with open(import_path, 'r') as f:
                presets_data = json.load(f)
        except json.JSONDecodeError:
            debug(f'Invalid JSON file: {import_path}')
            return
        
        # 設定ファイルを読み込み
        config_dir = self.ensure_config_dir()
        config_file = config_dir / 'config.py'
        
        if not config_file.exists():
            # 新しい設定ファイルを作成
            config_content = '''#!/usr/bin/env python3
from Xlib import X

# レイアウトプリセット設定
LAYOUT_PRESETS = {
'''
        else:
            # 既存の設定ファイルを読み込み
            with open(config_file, 'r') as f:
                config_content = f.read()
            
            # LAYOUT_PRESETSが存在しない場合は追加
            if 'LAYOUT_PRESETS = {' not in config_content:
                config_content += '''
# レイアウトプリセット設定
LAYOUT_PRESETS = {
'''
        
        # プリセットを追加
        for name, preset in presets_data.items():
            # プリセットの文字列を作成
            preset_str = f"    '{name}': {{\n"
            preset_str += f"        'name': '{preset['name']}',\n"
            preset_str += f"        'description': '{preset['description']}',\n"
            preset_str += f"        'windows': {preset['windows']}\n"
            preset_str += "    },\n"
            
            # 設定ファイルに追加
            insert_pos = config_content.find('LAYOUT_PRESETS = {') + len('LAYOUT_PRESETS = {')
            config_content = (
                config_content[:insert_pos] + '\n' + preset_str +
                config_content[insert_pos:]
            )
        
        # 設定ファイルを保存
        with open(config_file, 'w') as f:
            f.write(config_content)
        
        debug(f'Layout presets imported from {import_path}')
        
        # 設定を再読み込み
        self.reload_config()

    def cb_export_layout_presets(self, event, export_path=None):
        """レイアウトプリセットのエクスポートコールバック"""
        debug('callback: cb_export_layout_presets called')
        self.export_layout_presets(export_path)

    def cb_import_layout_presets(self, event, import_path=None):
        """レイアウトプリセットのインポートコールバック"""
        debug('callback: cb_import_layout_presets called')
        self.import_layout_presets(import_path)

    def show_preset_search(self):
        """プリセット検索ウィンドウを表示"""
        # 検索ウィンドウを作成
        search_win = self.screen.root.create_window(
            10, 10, 500, 400, 0,
            self.screen.root_depth,
            X.InputOutput,
            background_pixel=self.screen.white_pixel,
            override_redirect=True
        )
        
        # 検索結果を表示
        gc = search_win.create_gc(
            foreground=self.screen.black_pixel,
            background=self.screen.white_pixel
        )
        
        # カテゴリごとにプリセットを表示
        y = 10
        for category, category_name in self.preset_manager.categories.items():
            search_win.draw_text(gc, 10, y, f"【{category_name}】")
            y += 20
            
            # カテゴリに属するプリセットを検索
            presets = [
                (name, preset) for name, preset in self.config.LAYOUT_PRESETS.items()
                if self.preset_manager.metadata.get(name, {}).get('category') == category
            ]
            
            # 優先度でソート
            presets.sort(key=lambda x: -self.preset_manager.metadata.get(x[0], {}).get('priority', 0))
            
            for name, preset in presets:
                metadata = self.preset_manager.metadata.get(name, {})
                priority = metadata.get('priority', 0)
                auto_rules = len(metadata.get('auto_rules', []))
                
                current_mark = "* " if name == self.current_layout else "  "
                search_win.draw_text(gc, 20, y,
                    f"{current_mark}{preset.get('name', name)} "
                    f"(優先度: {priority}, 自動ルール: {auto_rules}件)")
                y += 15
                
                if preset.get('description'):
                    search_win.draw_text(gc, 40, y, f"説明: {preset['description']}")
                    y += 20
            
            y += 10
        
        # ウィンドウを表示
        search_win.map()
        
        # 10秒後に自動的に閉じる
        def close_search():
            time.sleep(10)
            search_win.destroy()
        
        Thread(target=close_search).start()

    def cb_show_preset_search(self, event):
        """プリセット検索表示のコールバック"""
        debug('callback: cb_show_preset_search called')
        self.show_preset_search()

    def handle_randr_notify(self, event):
        """RandRイベントのハンドラ（モニター接続状態の変更）"""
        debug('handler: handle_randr_notify called')
        self.monitor_manager.update_monitors()

def main():
    wm = Mosakuwm()
    try:
        wm.loop()
    except KeyboardInterrupt:
        sys.exit(0)

if __name__ == '__main__':
    main() 
