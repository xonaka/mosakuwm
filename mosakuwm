#!/usr/bin/env python3

import os
import sys
import subprocess
import re
import time
import math
import importlib.util
import logging
import traceback
from pathlib import Path
from Xlib import X, XK, display
from Xlib.ext import randr  # RandR拡張を追加
from threading import Thread
import json

# ロガーの設定
logger = logging.getLogger('mosakuwm')
logger.setLevel(logging.DEBUG)
fh = logging.FileHandler('debug.log', mode='w')
fh.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
fh.setFormatter(formatter)
logger.addHandler(fh)

# --- PresetManagerのダミークラスを追加 ---
class PresetManager:
    def __init__(self, wm):
        pass

def load_config():
    """設定ファイルを読み込む"""
    # 設定ファイルの検索順序
    config_paths = [
        Path.cwd() / 'config.py',  # カレントディレクトリ
        Path.home() / '.config' / 'mosakuwm' / 'config.py',  # ユーザー設定
    ]

    # デフォルト設定
    class DefaultConfig:
        # アプリケーション設定
        TERMINAL = 'urxvt'
        EDITOR = 'emacs'
        BROWSER = 'google-chrome'
        PRIORITY_WINDOW = EDITOR

        # ウィンドウ設定
        WINDOW_MIN_WIDTH = 1920/8
        WINDOW_MIN_HEIGHT = 1280/8
        INIT_PTR_POS = 30

        # フレーム設定
        FRAME_COLOR = 'SteelBlue3'
        FRAME_SPECIAL_COLOR = 'orange'
        FRAME_THICKNESS = 2

        # 仮想スクリーン設定
        MAX_VSCREEN = 4

        # タイル配置設定
        TILE_RATIOS = {
            'main_pane_ratio': 0.6,
            'grid_main_ratio': 0.5,
            'horizontal_ratios': [0.5],
            'vertical_ratios': [0.5],
        }

        # キーバインド設定
        KEY_BINDS = {}

        # パフォーマンス設定
        DRAG_INTERVAL = 1/60

        # ウィンドウルール設定
        WINDOW_RULES = {}
        WINDOW_POSITIONS = {}

        # レイアウトプリセット設定
        LAYOUT_PRESETS = {}

    config = DefaultConfig

    # 設定ファイルの読み込み
    for config_path in config_paths:
        if config_path.exists():
            try:
                spec = importlib.util.spec_from_file_location("config", config_path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                config = module
                debug(f'設定を読み込みました: {config_path}')
                break
            except Exception as e:
                debug(f'設定の読み込みに失敗しました: {config_path} - {str(e)}')

    return config

def debug(msg):
    """デバッグメッセージをログファイルと標準エラー出力に出力"""
    logger.debug(msg)
    print(msg, file=sys.stderr, flush=True)

def error(msg, exc_info=None):
    """エラーメッセージをログに出力"""
    if exc_info:
        logger.error(f"{msg}\n{traceback.format_exc()}")
    else:
        logger.error(msg)

def info(msg):
    """情報メッセージをログに出力"""
    logger.info(msg)

# 定数定義
LEFT = 1
RIGHT = 2
UPPER = 4
LOWER = 8
HORIZONTAL = 16
VERTICAL = 32

# 移動方向の定数
FORWARD = 0
BACKWARD = 1

# タイル配置パターンの定数
TILE_PATTERN_GRID = 0
TILE_PATTERN_HORIZONTAL = 1
TILE_PATTERN_VERTICAL = 2

class WindowAnimation:
    """ウィンドウアニメーションを管理するクラス"""
    def __init__(self, window, start_geom, end_geom, duration=0.3, fps=60):
        self.window = window
        self.start_geom = start_geom
        self.end_geom = end_geom
        self.duration = duration
        self.interval = 1.0 / fps
        self.start_time = None
        
    def start(self):
        """アニメーションを開始"""
        self.start_time = time.time()
        Thread(target=self._animate).start()
        
    def _animate(self):
        """アニメーションのメインループ"""
        while True:
            current_time = time.time()
            progress = (current_time - self.start_time) / self.duration
            
            if progress >= 1:
                # 最終位置に設定
                self.window.configure(
                    x=self.end_geom['x'],
                    y=self.end_geom['y'],
                    width=self.end_geom['width'],
                    height=self.end_geom['height']
                )
                break
                
            # イージング関数を適用（ease-in-out）
            t = progress
            if t < 0.5:
                progress = 2 * t * t
            else:
                t = 2 * t - 1
                progress = -0.5 * (t * (t - 2) - 1)
                
            # 現在の位置とサイズを計算
            current_x = self.start_geom['x'] + (self.end_geom['x'] - self.start_geom['x']) * progress
            current_y = self.start_geom['y'] + (self.end_geom['y'] - self.start_geom['y']) * progress
            current_width = self.start_geom['width'] + (self.end_geom['width'] - self.start_geom['width']) * progress
            current_height = self.start_geom['height'] + (self.end_geom['height'] - self.start_geom['height']) * progress
            
            # ウィンドウを更新
            self.window.configure(
                x=int(current_x),
                y=int(current_y),
                width=int(current_width),
                height=int(current_height)
            )
            
            time.sleep(self.interval)

class MonitorManager:
    """モニター管理を行うクラス"""
    def __init__(self, wm):
        self.wm = wm
        self.monitors = {}
        self.monitor_configs = {}
        self.load_monitor_configs()
        
    def load_monitor_configs(self):
        """モニター設定を読み込み"""
        config_dir = self.wm.ensure_config_dir()
        config_file = config_dir / 'monitor_config.json'
        
        if config_file.exists():
            try:
                with open(config_file, 'r') as f:
                    self.monitor_configs = json.load(f)
            except json.JSONDecodeError:
                debug('Invalid monitor config file')
                
    def save_monitor_configs(self):
        """モニター設定を保存"""
        config_dir = self.wm.ensure_config_dir()
        config_file = config_dir / 'monitor_config.json'
        
        with open(config_file, 'w') as f:
            json.dump(self.monitor_configs, f, indent=4)
            
    def update_monitors(self):
        """モニター情報を更新"""
        old_monitors = self.monitors.copy()
        self.monitors = self.wm.get_monitors_info()
        
        # 新しく接続されたモニターを検出
        for name, monitor in self.monitors.items():
            if monitor['connected'] and (name not in old_monitors or not old_monitors[name]['connected']):
                self.handle_monitor_connected(name, monitor)
                
        # 切断されたモニターを検出
        for name, monitor in old_monitors.items():
            if monitor['connected'] and (name not in self.monitors or not self.monitors[name]['connected']):
                self.handle_monitor_disconnected(name)
                
    def handle_monitor_connected(self, name, monitor):
        """モニター接続時の処理"""
        debug('handler: handle_monitor_connected called')
        debug(f'Monitor connected: {name}')
        
        # 保存された設定を適用
        if name in self.monitor_configs:
            config = self.monitor_configs[name]
            
            # レイアウトプリセットの適用
            if 'layout_preset' in config:
                self.wm.apply_layout_preset(config['layout_preset'])
                
            # ウィンドウの再配置
            if 'window_positions' in config:
                for window_class, pos in config['window_positions'].items():
                    for window in self.wm.exposed_windows:
                        if self.wm.get_window_class(window) == window_class:
                            window.configure(
                                x=pos['x'] + monitor['geometry']['x'],
                                y=pos['y'] + monitor['geometry']['y']
                            )
                            
    def handle_monitor_disconnected(self, name):
        """モニター切断時の処理"""
        debug('handler: handle_monitor_disconnected called')
        debug(f'Monitor disconnected: {name}')
        
        # 現在のウィンドウ配置を保存
        if name not in self.monitor_configs:
            self.monitor_configs[name] = {}
            
        config = self.monitor_configs[name]
        config['window_positions'] = {}
        
        for window in self.wm.exposed_windows:
            if self.wm.managed_windows.get(window, {}).get('name') == name:
                geom = self.wm.get_window_geometry(window)
                if geom:
                    window_class = self.wm.get_window_class(window)
                    config['window_positions'][window_class] = {
                        'x': geom.x - self.monitors[name]['geometry']['x'],
                        'y': geom.y - self.monitors[name]['geometry']['y']
                    }
                    
        self.save_monitor_configs()
        
        # ウィンドウをプライマリモニターに移動
        primary = self.get_primary_monitor()
        if primary and primary['name'] != name:
            for window in self.wm.exposed_windows:
                if self.wm.managed_windows.get(window, {}).get('name') == name:
                    self.wm.move_window_to_monitor(window, primary)
                    
    def get_primary_monitor(self):
        """プライマリモニターを取得"""
        for name, monitor in self.monitors.items():
            if monitor['connected'] and monitor['primary']:
                monitor['name'] = name
                return monitor
        return None
        
    def set_monitor_layout_preset(self, monitor_name, preset_name):
        """モニターのデフォルトレイアウトプリセットを設定"""
        if monitor_name not in self.monitor_configs:
            self.monitor_configs[monitor_name] = {}
        self.monitor_configs[monitor_name]['layout_preset'] = preset_name
        self.save_monitor_configs()

class Mosakuwm:
    def __init__(self):
        """初期化"""
        try:
            self.current_layout = None  # ← ここで先に初期化
            self.display = display.Display()
            self.screen = self.display.screen()
            # RandR拡張を有効化
            try:
                self.display.xrandr_query_version()
            except Exception as e:
                print(f"警告: RandR拡張の初期化に失敗しました: {e}")
            # 他のウィンドウマネージャーが実行中かチェック＆イベントマスクを一度だけまとめて設定
            try:
                self.screen.root.change_attributes(
                    event_mask = X.SubstructureRedirectMask |
                    X.SubstructureNotifyMask |
                    X.EnterWindowMask |
                    X.LeaveWindowMask |
                    X.FocusChangeMask |
                    X.ButtonPressMask |
                    X.ButtonReleaseMask |
                    X.PointerMotionMask |
                    randr.RRScreenChangeNotifyMask
                )
            except Exception as e:
                print("エラー: 他のウィンドウマネージャーが実行中です")
                print("ヒント: 既存のウィンドウマネージャーを終了してから再試行してください")
                sys.exit(1)
            # 残りの初期化処理
            self.colormap = self.screen.default_colormap
            # 設定の読み込み
            self.config = load_config()
            # キーバインド関連
            self.keybinds = {}
            self.pressed_keys = set()
            # ウィンドウ管理用の辞書とリスト
            self.managed_windows = {}
            self.exposed_windows = []
            self.framed_window = None
            # フレーム関連
            self.frame_windows = {}
            self.special_window = []
            # 仮想スクリーン関連
            self.window_vscreen = {}
            self.current_vscreen = 0
            # ドラッグ操作用の変数
            self.start = None
            self.start_geom = None
            self.last_dragged_time = time.time()
            # モニター情報の初期化
            self.monitor_geometries = self.get_available_monitor_geometries()
            self.maxsize = self.get_screen_size()
            # フレームウィンドウの作成
            self.create_frame_windows()
            # イベントの捕捉を開始
            # self.catch_events()  # 不要: 既にroot.change_attributesで設定済み
            self.grab_buttons()
            self.grab_keys()
            # プリセットマネージャーの初期化
            self.preset_manager = PresetManager(self)
            # モニターマネージャーの初期化
            self.monitor_manager = MonitorManager(self)
            # 既存のウィンドウを管理対象に追加
            for child in self.screen.root.query_tree().children:
                try:
                    if child.get_attributes().map_state:
                        self.manage_window(child)
                except Exception as e:
                    debug(f'child manage_window error: {e}')
            # タイル配置関連
            self.current_main_ratio = self.config.TILE_RATIOS['main_pane_ratio']
            self.current_tile_pattern = TILE_PATTERN_GRID
            # ウィンドウルール関連
            self.floating_windows = set()  # フローティングウィンドウを保持
            # レイアウト関連
            self.layout_windows = {}  # レイアウトに属するウィンドウを保持
        except Exception as e:
            print(f"初期化中にエラーが発生しました: {e}")
            debug(f"初期化中にエラーが発生しました: {e}")
            sys.exit(1)

    def get_screen_size(self):
        """スクリーン全体のサイズを取得"""
        lines = subprocess.getoutput('xrandr').split('\n')
        match = re.search(r'current (\d+) x (\d+)', lines[0])
        return {
            'width': int(match.group(1)),
            'height': int(match.group(2))
        }

    def get_available_monitor_geometries(self):
        """利用可能なモニターの情報を取得"""
        debug('function: get_available_monitor_geometries called')
        monitors = self.get_monitors_info()
        geometries = {}
        for name, monitor in monitors.items():
            if monitor['connected']:
                geom = monitor['geometry']
                if not geom:
                    debug(f'Monitor {name} is connected but not mapped.')
                    continue
                geometries[name] = {
                    'name': name,
                    'width': geom['width'],
                    'height': geom['height'],
                    'x': geom['x'],
                    'y': geom['y']
                }
        return geometries

    def get_monitors_info(self):
        """xrandrを使用して接続されているモニターの情報を取得"""
        debug('function: get_monitors_info called')
        lines = subprocess.getoutput('xrandr').split('\n')
        monitors = {}
        for line in lines[1:]:
            if 'connected' in line:
                name = line.split()[0]
                connected = ' connected' in line
                try:
                    m = re.search(r'(\d+)x(\d+)\+(\d+)\+(\d+)', line)
                    width = int(m.group(1))
                    height = int(m.group(2))
                    x = int(m.group(3))
                    y = int(m.group(4))
                    geom = {
                        'width': width,
                        'height': height,
                        'x': x,
                        'y': y
                    }
                except:
                    geom = None
                primary = 'primary' in line
                monitors[name] = {
                    'connected': connected,
                    'geometry': geom,
                    'primary': primary
                }
        return monitors

    def get_monitor_coverarea(self, wgeom, mgeom):
        """ウィンドウとモニターの重なり面積を計算"""
        xmin = min(wgeom.x, mgeom['x'])
        xmax = max(wgeom.x + wgeom.width, mgeom['x'] + mgeom['width'])
        xsum = wgeom.width + mgeom['width']
        xcover = max(0, xsum - (xmax - xmin))
        
        ymin = min(wgeom.y, mgeom['y'])
        ymax = max(wgeom.y + wgeom.height, mgeom['y'] + mgeom['height'])
        ysum = wgeom.height + mgeom['height']
        ycover = max(0, ysum - (ymax - ymin))
        
        return xcover * ycover

    def get_monitor_geometry_with_window(self, window):
        """ウィンドウが最も重なっているモニターのジオメトリを取得"""
        geom = self.get_window_geometry(window)
        if not geom:
            return list(self.monitor_geometries.values())[0]

        maxcoverage = 0
        maxmonitor = list(self.monitor_geometries.values())[0]
        
        for name, monitor in self.monitor_geometries.items():
            coverarea = self.get_monitor_coverarea(geom, monitor)
            coverage = coverarea / (monitor['width'] * monitor['height'])
            normcoverage = coverarea * coverage
            if maxcoverage < normcoverage:
                maxcoverage = normcoverage
                maxmonitor = monitor
        
        return maxmonitor

    def move_window_to_monitor(self, window, dst):
        """ウィンドウを指定したモニターに移動"""
        if window not in self.managed_windows.keys():
            return
            
        src = self.managed_windows.get(window, None)
        if src is None:
            return
            
        wgeom = self.get_window_geometry(window)
        if wgeom is None:
            return
            
        # 移動先モニターのサイズに合わせてウィンドウをスケーリング
        hratio = dst['width'] / src['width']
        vratio = dst['height'] / src['height']
        
        xd = wgeom.x - src['x']
        yd = wgeom.y - src['y']
        
        x = int(xd * hratio) + dst['x']
        y = int(yd * vratio) + dst['y']
        width = int(wgeom.width * hratio)
        height = int(wgeom.height * vratio)
        
        window.configure(
            x=x,
            y=y,
            width=width,
            height=height
        )
        self.managed_windows[window] = dst
        self.draw_frame_windows()

    def move_window_to_next_monitor(self, window):
        """ウィンドウを次のモニターに移動"""
        if window not in self.exposed_windows:
            return
            
        src = self.managed_windows.get(window, None)
        if src is None:
            return
            
        monitors = list(self.monitor_geometries.values())
        srcidx = monitors.index(src)
        dstidx = (srcidx + 1) % len(monitors)
        dst = monitors[dstidx]
        
        self.move_window_to_monitor(window, dst)

    def catch_events(self):
        """ルートウィンドウのイベントをキャッチするための設定"""
        self.screen.root.change_attributes(
            event_mask = X.SubstructureRedirectMask |
            X.SubstructureNotifyMask |
            X.EnterWindowMask |
            X.LeaveWindowMask |
            X.FocusChangeMask |
            X.ButtonPressMask |
            X.ButtonReleaseMask |
            X.PointerMotionMask |
            randr.RRScreenChangeNotifyMask  # 既に修正済み
        )

    def grab_buttons(self):
        """マウスボタンのグラブ設定"""
        debug('function: grab_buttons called')
        for button in [1, 3]:
            try:
                self.screen.root.grab_button(
                    button,
                    X.Mod1Mask,
                    True,
                    X.ButtonPressMask |
                    X.ButtonReleaseMask |
                    X.PointerMotionMask,
                    X.GrabModeAsync,
                    X.GrabModeAsync,
                    X.NONE,
                    X.NONE)
            except Exception as e:
                debug(f'grab_button failed: {e}')

    def grab_keys(self):
        """キーバインドの設定"""
        debug('function: grab_keys called')
        for (key, modifier), rule in self.config.KEY_BINDS.items():
            keysym = XK.string_to_keysym(key)
            keycode = self.display.keysym_to_keycode(keysym)
            if modifier is None:
                continue
            try:
                self.screen.root.grab_key(
                    keycode,
                    modifier,
                    True,
                    X.GrabModeAsync,
                    X.GrabModeAsync
                )
                self.keybinds[(keycode, modifier)] = rule
                debug(f'debug: ({key}, {modifier}) grabbed as ({keycode}, {modifier})')
            except Exception as e:
                debug(f'grab_key failed: {e}')

    def handle_button_press(self, event):
        """マウスボタンが押された時の処理"""
        debug('handler: handle_button_press called')
        window = event.child
        if window in self.frame_windows.values():
            return  # フレーム自体は無視
        if window not in self.managed_windows.keys():
            return
        self.screen.root.grab_pointer(
            True,
            X.PointerMotionMask |
            X.ButtonReleaseMask,
            X.GrabModeAsync,
            X.GrabModeAsync,
            X.NONE,
            X.NONE,
            0)
        self.focus_window(window)
        self.start = event
        self.start_geom = self.get_window_geometry(window)

    def handle_button_release(self, event):
        """マウスボタンが離された時の処理"""
        debug('handler: handle_button_release called')
        self.display.ungrab_pointer(0)
        if event.child in self.managed_windows:
            # ウィンドウの所属モニターを更新
            self.managed_windows[event.child] = self.get_monitor_geometry_with_window(event.child)

    def handle_motion_notify(self, event):
        """マウスポインタが移動した時の処理"""
        debug('handler: handle_motion_notify called')
        if self.start is None or self.start.child == X.NONE:
            return
        now = time.time()
        if now - self.last_dragged_time < self.config.DRAG_INTERVAL:
            return
        self.last_dragged_time = now
        xdiff = event.root_x - self.start.root_x
        ydiff = event.root_y - self.start.root_y
        if event.child in self.frame_windows.values():
            return  # フレーム自体は無視
        if self.start.detail == 1:
            self.start.child.configure(
                x=self.start_geom.x + xdiff,
                y=self.start_geom.y + ydiff
            )
        elif self.start.detail == 3:
            new_width = self.start_geom.width + xdiff
            new_height = self.start_geom.height + ydiff
            if new_width <= self.config.WINDOW_MIN_WIDTH or new_height <= self.config.WINDOW_MIN_HEIGHT:
                return
            self.start.child.configure(
                width=new_width,
                height=new_height
            )
        self.draw_frame_windows()

    def manage_window(self, window):
        attrs = self.get_window_attributes(window)
        if window in self.managed_windows.keys():
            return
        if attrs is None:
            return
        if attrs.override_redirect:
            return
        geom = self.get_window_geometry(window)
        if not geom:
            return
        # フレーム化・reparentをやめる
        self.managed_windows[window] = self.get_monitor_geometry_with_window(window)
        # 仮想スクリーン割り当て
        self.window_vscreen[window] = self.current_vscreen
        # 表示更新
        self.update_visible_windows()
        self.apply_window_rules(window)
        self.apply_layout(window)
        window.change_attributes(
            event_mask=X.EnterWindowMask | X.LeaveWindowMask
        )
        window.configure(stack_mode=X.Above)
        self.draw_frame_windows()

    def get_window_attributes(self, window):
        """ウィンドウの属性を取得"""
        try:
            return window.get_attributes()
        except:
            return None

    def get_window_geometry(self, window):
        """ウィンドウのジオメトリを取得"""
        try:
            return window.get_geometry()
        except:
            return None

    def handle_key_press(self, event):
        """キーが押された時の処理"""
        debug('handler: handle_key_press called')
        keycode = event.detail
        modifier = event.state
        entry = (keycode, modifier)
        
        rule = self.keybinds.get(entry, None)
        if rule:
            if 'method' in rule:
                method = getattr(self, rule['method'], None)
                if method:
                    arg = rule.get('arg', None)
                    if arg is not None:
                        method(event, arg)
                    else:
                        method(event)
            elif 'command' in rule:
                os.system(rule['command'])

    def cb_focus_next_window(self, event, direction=FORWARD):
        """次のウィンドウにフォーカスを移動"""
        debug('callback: cb_focus_next_window called')
        if not self.exposed_windows:
            return
            
        if self.framed_window in self.exposed_windows:
            idx = self.exposed_windows.index(self.framed_window)
            if direction == FORWARD:
                idx = (idx + 1) % len(self.exposed_windows)
            else:
                idx = (idx - 1) % len(self.exposed_windows)
        else:
            idx = 0
            
        next_window = self.exposed_windows[idx]
        self.focus_window(next_window)
        next_window.warp_pointer(self.config.INIT_PTR_POS, self.config.INIT_PTR_POS)

    def focus_window(self, window):
        """指定したウィンドウにフォーカスを設定"""
        debug('function: focus_window called')
        if window not in self.exposed_windows:
            return
        try:
            attrs = window.get_attributes()
            if attrs and attrs.map_state:
                window.set_input_focus(X.RevertToParent, 0)
        except Exception as e:
            debug(f'focus_window error: {e}')
        window.configure(stack_mode=X.Above)
        self.framed_window = window
        self.draw_frame_windows()

    def cb_halve_window(self, event, direction):
        """ウィンドウを半分のサイズに変更"""
        debug('callback: cb_halve_window called')
        if not self.framed_window:
            return
            
        self.halve_window(self.framed_window, direction)
        self.framed_window.warp_pointer(self.config.INIT_PTR_POS, self.config.INIT_PTR_POS)

    def halve_window(self, window, direction):
        """ウィンドウを指定した方向に半分のサイズにする"""
        if window not in self.exposed_windows:
            return
            
        geom = self.get_window_geometry(window)
        if not geom:
            return
            
        if direction & (LEFT | RIGHT) != 0 and geom.width <= self.config.WINDOW_MIN_WIDTH:
            return
        if direction & (UPPER | LOWER) != 0 and geom.height <= self.config.WINDOW_MIN_HEIGHT:
            return
            
        x, y = geom.x, geom.y
        width, height = geom.width, geom.height
        
        if direction & (LEFT | RIGHT) != 0:
            width //= 2
        if direction & (UPPER | LOWER) != 0:
            height //= 2
            
        if direction & RIGHT != 0:
            x += width
        if direction & LOWER != 0:
            y += height
            
        window.configure(
            x=x,
            y=y,
            width=width,
            height=height
        )
        self.draw_frame_windows()

    def cb_move_window_to_next_monitor(self, event):
        """ウィンドウを次のモニターに移動"""
        debug('callback: cb_move_window_to_next_monitor called')
        if not self.framed_window:
            return
            
        self.move_window_to_next_monitor(self.framed_window)
        self.framed_window.warp_pointer(self.config.INIT_PTR_POS, self.config.INIT_PTR_POS)

    def loop(self):
        """メインイベントループ"""
        while True:
            try:
                event = self.display.next_event()
                debug(f"event received: {event.type}")
                if event.type == X.MapRequest:
                    self.handle_map_request(event)
                elif event.type == X.DestroyNotify:
                    self.handle_destroy_notify(event)
                elif event.type == X.ButtonPress:
                    self.handle_button_press(event)
                elif event.type == X.ButtonRelease:
                    self.handle_button_release(event)
                elif event.type == X.MotionNotify:
                    self.handle_motion_notify(event)
                elif event.type == X.KeyPress:
                    self.handle_key_press(event)
                try:
                    if hasattr(self.display.extension_event, 'RRScreenChangeNotify') and \
                       event.type == self.display.extension_event.RRScreenChangeNotify:
                        self.handle_randr_notify(event)
                except AttributeError:
                    pass
            except Exception as e:
                debug(f'event loop error: {e}')

    def handle_map_request(self, event):
        """新しいウィンドウが作成された時のハンドラ"""
        debug('handler: handle_map_request called')
        self.manage_window(event.window)

    def handle_destroy_notify(self, event):
        """ウィンドウが破棄された時のハンドラ"""
        debug('handler: handle_destroy_notify called')
        if event.window in self.managed_windows:
            self.managed_windows.pop(event.window)
            if event.window in self.exposed_windows:
                self.exposed_windows.remove(event.window)
            if event.window in self.window_vscreen:
                self.window_vscreen.pop(event.window)
            if event.window == self.framed_window:
                self.framed_window = None
                self.unmap_frame_windows()

    def select_vscreen(self, num):
        """指定した仮想スクリーンに切り替え"""
        debug('function: select_vscreen called')
        if num < 0 or num >= self.config.MAX_VSCREEN:
            return
        self.current_vscreen = num
        self.update_visible_windows()

    def send_window_to_next_vscreen(self, window, direction):
        """ウィンドウを次または前の仮想スクリーンに移動し、作業場所も追従"""
        debug('function: send_window_to_next_vscreen called')
        if window not in self.managed_windows:
            return
        cur = self.window_vscreen.get(window, 0)
        if direction == 0:  # FORWARD
            next_v = (cur + 1) % self.config.MAX_VSCREEN
        else:  # BACKWARD
            next_v = (cur - 1) % self.config.MAX_VSCREEN
        self.window_vscreen[window] = next_v
        # ここで作業場所もウィンドウの移動先に合わせて切り替える
        self.current_vscreen = next_v
        self.update_visible_windows()

    def create_frame_windows(self):
        """フレームウィンドウの作成"""
        debug('function: create_frame_windows called')
        self.frame_pixel = self.colormap.alloc_named_color(self.config.FRAME_COLOR).pixel
        for side in ['left', 'right', 'upper', 'lower']:
            # サイズ・位置は後でdraw_frame_windowsで調整するので仮でOK
            window = self.screen.root.create_window(
                0, 0, self.config.FRAME_THICKNESS if side in ['left', 'right'] else 16,
                self.config.FRAME_THICKNESS if side in ['upper', 'lower'] else 16,
                0,
                self.screen.root_depth,
                X.InputOutput,
                background_pixel=self.frame_pixel,
                override_redirect=True
            )
            window.map()
            self.frame_windows[side] = window

    def draw_frame_windows(self):
        """フレームウィンドウの描画"""
        if self.framed_window is None:
            return
        # フレームの色を設定
        if self.framed_window in self.special_window:
            new_frame_pixel = self.colormap.alloc_named_color(self.config.FRAME_SPECIAL_COLOR).pixel
        else:
            new_frame_pixel = self.colormap.alloc_named_color(self.config.FRAME_COLOR).pixel
        for side in ['left', 'right', 'upper', 'lower']:
            self.frame_windows[side].change_attributes(background_pixel=new_frame_pixel)
            self.frame_windows[side].clear_area(0, 0, 0, 0, True)
        geom = self.get_window_geometry(self.framed_window)
        if geom is None:
            return
        for side in ['left', 'right', 'upper', 'lower']:
            x, y, width, height = 0, 0, 0, 0
            if side == 'left':
                x = geom.x
                y = geom.y
                width = self.config.FRAME_THICKNESS
                height = geom.height
            elif side == 'right':
                x = geom.x + geom.width - self.config.FRAME_THICKNESS
                y = geom.y
                width = self.config.FRAME_THICKNESS
                height = geom.height
            elif side == 'upper':
                x = geom.x
                y = geom.y
                width = geom.width
                height = self.config.FRAME_THICKNESS
            elif side == 'lower':
                x = geom.x
                y = geom.y + geom.height - self.config.FRAME_THICKNESS
                width = geom.width
                height = self.config.FRAME_THICKNESS
            self.frame_windows[side].configure(
                x=x,
                y=y,
                width=width,
                height=height,
                stack_mode=X.Above
            )
            self.frame_windows[side].map()

    def map_frame_windows(self):
        """フレームウィンドウを表示"""
        for side in ['left', 'right', 'upper', 'lower']:
            self.frame_windows[side].map()

    def unmap_frame_windows(self):
        """フレームウィンドウを非表示"""
        for side in ['left', 'right', 'upper', 'lower']:
            self.frame_windows[side].unmap()

    def get_tile_layout(self, tile_num):
        """タイル配置のレイアウトを計算"""
        debug('function: get_tile_layout called')
        tmp = int(math.sqrt(tile_num))
        # (row, col)を返す
        if tmp**2 == tile_num:
            return (tmp, tmp)
        if (tmp+1)*tmp >= tile_num:
            return (tmp, tmp+1)
        return (tmp+1, tmp+1)

    def set_window_to_stack_top(self, window):
        """ウィンドウをexposed_windowsの先頭に移動し、X上でも最前面に"""
        if window not in self.exposed_windows:
            return
        idx = self.exposed_windows.index(window)
        self.exposed_windows.pop(idx)
        self.exposed_windows.insert(0, window)
        window.configure(stack_mode=X.Above)

    def tile_windows(self, window, pattern=None):
        debug(f'function: tile_windows called (pattern={pattern})')
        monitor = self.managed_windows.get(window, None)
        if monitor is None:
            return
        target_windows = []
        for win in self.exposed_windows:
            if monitor == self.managed_windows.get(win, None):
                target_windows.append(win)
        def sort_key(window):
            return window.id
        target_windows.sort(key=sort_key)
        # patternによる分岐（今は未実装だが将来の拡張用）
        nrows, ncols = self.get_tile_layout(len(target_windows))
        offcuts_num = nrows*ncols - len(target_windows)
        eidx = None
        for i in range(len(target_windows)):
            if self.config.PRIORITY_WINDOW in self.get_window_class(target_windows[i]).lower():
                eidx = i
        if eidx is not None:
            target_windows[eidx], target_windows[ncols*(nrows-1)-1] = \
                target_windows[ncols*(nrows-1)-1], target_windows[eidx]
        for row in reversed(range(nrows)):
            for col in reversed(range(ncols)):
                if not target_windows:
                    break
                win = target_windows.pop(0)
                x = monitor['x'] + monitor['width']*col//ncols
                width = monitor['width']//ncols
                if row == 1 and col < offcuts_num:
                    height = monitor['height']*2//nrows
                    y = 0 + monitor['y']
                else:
                    height = monitor['height']//nrows
                    y = monitor['y'] + monitor['height']*row//nrows
                win.configure(x=x, y=y, width=width, height=height)
        window.warp_pointer(self.config.INIT_PTR_POS, self.config.INIT_PTR_POS)
        self.set_window_to_stack_top(window)

    def cb_tile_windows(self, event, pattern=None, *args, **kwargs):
        """タイル配置のコールバック"""
        debug(f'callback: cb_tile_windows called (pattern={pattern})')
        if not self.framed_window:
            return
        self.tile_windows(self.framed_window, pattern)
        self.focus_window(self.framed_window)

    def get_window_class(self, window):
        """ウィンドウのクラス名を取得"""
        try:
            cmd, cls = window.get_wm_class()
            return cls if cls is not None else ''
        except:
            return ''

    def cb_adjust_main_ratio(self, event, delta):
        """メインペインの比率を調整"""
        debug('callback: cb_adjust_main_ratio called')
        new_ratio = self.current_main_ratio + delta
        if 0.1 <= new_ratio <= 0.9:  # 比率の範囲を制限
            self.current_main_ratio = new_ratio
            if self.framed_window:
                self.tile_windows(self.framed_window)

    def cb_reset_main_ratio(self, event):
        """メインペインの比率をリセット"""
        debug('callback: cb_reset_main_ratio called')
        self.current_main_ratio = self.config.TILE_RATIOS['main_pane_ratio']
        if self.framed_window:
            self.tile_windows(self.framed_window)

    def reload_config(self):
        """設定を再読み込み"""
        debug('function: reload_config called')
        old_config = self.config
        self.config = load_config()

        # キーバインドの再設定
        self.ungrab_keys()
        self.grab_keys()

        # フレームの再設定
        if (self.config.FRAME_COLOR != old_config.FRAME_COLOR or
            self.config.FRAME_SPECIAL_COLOR != old_config.FRAME_SPECIAL_COLOR or
            self.config.FRAME_THICKNESS != old_config.FRAME_THICKNESS):
            self.recreate_frame_windows()

        # タイル配置の更新
        if self.framed_window:
            self.tile_windows(self.framed_window)

    def ungrab_keys(self):
        """キーバインドを解除"""
        debug('function: ungrab_keys called')
        for keycode, modifier in self.keybinds.keys():
            self.screen.root.ungrab_key(keycode, modifier)
        self.keybinds.clear()

    def recreate_frame_windows(self):
        """フレームウィンドウを再作成"""
        debug('function: recreate_frame_windows called')
        # 既存のフレームを削除
        for window in self.frame_windows.values():
            window.destroy()
        self.frame_windows.clear()
        
        # フレームを再作成
        self.create_frame_windows()

    def cb_reload_config(self, event):
        """設定再読み込みのコールバック"""
        debug('callback: cb_reload_config called')
        self.reload_config()

    def apply_window_rules(self, window):
        """ウィンドウルールを適用"""
        debug('function: apply_window_rules called')
        window_class = self.get_window_class(window)
        if not window_class:
            return

        # ウィンドウルールの取得
        rule = self.config.WINDOW_RULES.get(window_class.lower(), {})
        
        # 特別な色の設定
        if rule.get('special_color', False):
            self.special_window.append(window)
        
        # フローティングの設定
        if rule.get('floating', False):
            self.floating_windows.add(window)
        
        # 仮想スクリーンの設定
        if 'vscreen' in rule:
            self.window_vscreen[window] = rule['vscreen']
            if rule['vscreen'] != self.current_vscreen:
                window.unmap()
            else:
                window.map()
        
        # モニターの設定
        if 'monitor' in rule:
            monitor_idx = rule['monitor']
            monitors = list(self.monitor_geometries.values())
            if 0 <= monitor_idx < len(monitors):
                self.managed_windows[window] = monitors[monitor_idx]
        
        # 位置の設定
        if 'position' in rule:
            self.apply_window_position(window, rule['position'])

    def apply_window_position(self, window, position_name):
        """ウィンドウの位置を設定"""
        debug('function: apply_window_position called')
        monitor = self.managed_windows.get(window, None)
        if not monitor or position_name not in self.config.WINDOW_POSITIONS:
            return

        geom = self.get_window_geometry(window)
        if not geom:
            return

        position = self.config.WINDOW_POSITIONS[position_name]
        x = position['x']
        y = position['y']

        # パーセンテージ指定の場合は計算
        if isinstance(x, str) and x.endswith('%'):
            x = monitor['x'] + (monitor['width'] - geom.width) * int(x[:-1]) // 100
        else:
            x = monitor['x'] + (x if x >= 0 else monitor['width'] - geom.width + x)

        if isinstance(y, str) and y.endswith('%'):
            y = monitor['y'] + (monitor['height'] - geom.height) * int(y[:-1]) // 100
        else:
            y = monitor['y'] + (y if y >= 0 else monitor['height'] - geom.height + y)

        window.configure(
            x=x,
            y=y
        )

    def get_primary_monitor(self):
        """プライマリモニターを取得"""
        for monitor in self.monitor_geometries.values():
            if monitor.get('primary', False):
                return monitor
        return list(self.monitor_geometries.values())[0] if self.monitor_geometries else None

    def get_command_for_class(self, window_class):
        """ウィンドウクラスに対応するコマンドを取得"""
        class_to_command = {
            'urxvt': self.config.TERMINAL,
            'emacs': self.config.EDITOR,
            'google-chrome': self.config.BROWSER
        }
        return class_to_command.get(window_class)

    def calculate_window_geometry(self, window_config, monitor):
        """ウィンドウの位置とサイズを計算"""
        position = window_config['position']
        ratio = window_config.get('ratio', 1.0)
        split = window_config.get('split', 'horizontal')

        # 基本サイズの計算
        if split == 'vertical':
            width = int(monitor['width'] * ratio)
            height = monitor['height']
        else:
            width = monitor['width']
            height = int(monitor['height'] * ratio)

        # 位置の計算
        if position == 'left':
            x = monitor['x']
            y = monitor['y']
        elif position == 'right':
            x = monitor['x'] + monitor['width'] - width
            y = monitor['y']
        elif position == 'top':
            x = monitor['x']
            y = monitor['y']
        elif position == 'bottom':
            x = monitor['x']
            y = monitor['y'] + monitor['height'] - height
        elif position == 'top_left':
            x = monitor['x']
            y = monitor['y']
        elif position == 'top_right':
            x = monitor['x'] + monitor['width'] - width
            y = monitor['y']
        elif position == 'bottom_left':
            x = monitor['x']
            y = monitor['y'] + monitor['height'] - height
        elif position == 'bottom_right':
            x = monitor['x'] + monitor['width'] - width
            y = monitor['y'] + monitor['height'] - height
        else:  # center
            x = monitor['x'] + (monitor['width'] - width) // 2
            y = monitor['y'] + (monitor['height'] - height) // 2

        return x, y, width, height

    def ensure_config_dir(self):
        """設定ディレクトリの存在を確認し、必要に応じて作成"""
        config_dir = Path.home() / '.config' / 'mosakuwm'
        if not config_dir.exists():
            config_dir.mkdir(parents=True)
        return config_dir

    def handle_randr_notify(self, event):
        """RandRイベントのハンドラ（モニター接続状態の変更）"""
        debug('handler: handle_randr_notify called')
        self.monitor_manager.update_monitors()

    def apply_layout(self, window):
        """ウィンドウにレイアウトを適用"""
        debug('function: apply_layout called')
        
        # 現在のレイアウトが設定されていない場合は何もしない
        if not self.current_layout:
            return
            
        # レイアウトプリセットを取得
        preset = self.config.LAYOUT_PRESETS.get(self.current_layout)
        if not preset:
            return
            
        # ウィンドウのクラスを取得
        window_class = self.get_window_class(window)
        if not window_class:
            return
            
        # プリセット内のウィンドウ設定を検索
        window_config = None
        for config in preset['windows']:
            if config['class'] == window_class:
                window_config = config
                break
                
        if not window_config:
            return
            
        # モニター情報を取得
        monitor = self.get_primary_monitor()
        if not monitor:
            return
            
        # ウィンドウの位置とサイズを計算
        x, y, width, height = self.calculate_window_geometry(window_config, monitor)
        
        # ウィンドウを設定された位置に移動
        window.configure(
            x=x,
            y=y,
            width=width,
            height=height
        )
        
        # レイアウト管理用の辞書に追加
        self.layout_windows[window] = window_config
        self.draw_frame_windows()

    def maximize_window(self, window, mask):
        if window not in self.exposed_windows:
            return
        monitor = self.managed_windows.get(window, None)
        if monitor is None:
            return
        geom = self.get_window_geometry(window)
        x = geom.x
        y = geom.y
        width = geom.width
        height = geom.height
        if mask & VERTICAL != 0:
            y = monitor['y']
            height = monitor['height']
        if mask & HORIZONTAL != 0:
            x = monitor['x']
            width = monitor['width']
        window.configure(
            x=x,
            y=y,
            width=width,
            height=height)

    def cb_maximize_window(self, event, mask=HORIZONTAL|VERTICAL):
        debug('callback: cb_maximize_window called')
        window = self.framed_window
        if window:
            self.maximize_window(window, mask)
            window.warp_pointer(self.config.INIT_PTR_POS, self.config.INIT_PTR_POS)
            self.draw_frame_windows()

    def update_visible_windows(self):
        """現在の仮想スクリーンに属するウィンドウだけmap/unmap"""
        self.exposed_windows = []
        for window in self.managed_windows:
            if self.window_vscreen.get(window, 0) == self.current_vscreen:
                window.map()
                self.exposed_windows.append(window)
            else:
                window.unmap()

    def cb_select_vscreen(self, event, num):
        self.select_vscreen(num)

    def cb_send_window_to_next_vscreen(self, event, direction):
        if self.framed_window:
            self.send_window_to_next_vscreen(self.framed_window, direction)

def main():
    wm = Mosakuwm()
    try:
        wm.loop()
    except KeyboardInterrupt:
        sys.exit(0)

if __name__ == '__main__':
    main() 
