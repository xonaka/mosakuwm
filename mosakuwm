#!/usr/bin/env python3

import os
import sys
import subprocess
import re
import datetime
import time
import math
import signal
from Xlib import X, XK, display
from Xlib.ext import randr

# --- mosakuwm 設定・定数 ---
# ウィンドウ操作や見た目の基本パラメータ
INIT_PTR_POS = 30  # ウィンドウ操作時のポインタ初期位置
WINDOW_MIN_WIDTH = 1920/8  # ウィンドウの最小幅
WINDOW_MIN_HEIGHT = 1280/8  # ウィンドウの最小高さ
DRAG_INTERVAL = 1/60  # ドラッグ時の最小間隔（秒）

# ウィンドウ分割・移動用のビットマスク
LEFT = 1
RIGHT = 2
UPPER = 4
LOWER = 8
HORIZONTAL = 1
VERTICAL = 2
FORWARD = 0
BACKWARD = 1

MAX_VSCREEN = 4  # 仮想スクリーン最大数

EDITOR = 'emacs'  # 優先エディタ
TERMINAL = 'urxvt'  # デフォルト端末
BROWSER = 'google-chrome'  # デフォルトブラウザ
PRIORITY_WINDOW = EDITOR  # タイル時に優先するウィンドウ

FRAME_COLOR = 'SteelBlue3'  # 通常枠色
FRAME_SPECIAL_COLOR = 'orange'  # 特殊枠色
FRAME_THICKNESS = 2  # 枠の太さ
FONT = '-misc-fixed-bold-r-normal--18-120-100-100-c-90-iso10646-1'  # フォント
SCREENSHOT_DIR = f'{os.getenv("HOME")}/screenshots'  # スクリーンショット保存先
RECORDING_PROCESS = None  # 録画プロセス管理

# --- Xイベントとハンドラの対応表 ---
# Xlibイベントタイプとmosakuwmのハンドラ名を紐付ける
# XRandRイベントは__init__で動的に追加
EVENTS = {
    X.ButtonPress: 'handle_button_press',
    X.ButtonRelease: 'handle_button_release',
    X.MotionNotify: 'handle_motion_notify',
    X.EnterNotify: 'handle_enter_notify',
    X.MapNotify: 'handle_map_notify',
    X.UnmapNotify: 'handle_unmap_notify',
    X.MapRequest: 'handle_map_request',
    X.DestroyNotify: 'handle_destroy_notify',
    X.KeyPress: 'handle_key_press',
    X.KeyRelease: 'handle_key_release',
    X.ConfigureRequest: 'handle_configure_request'
    # XRandRイベントは__init__で追加
}


KEY_BINDS = {
    # --- アプリ起動系 ---  
    # アプリ起動
    ('1', X.Mod1Mask | X.ControlMask): {
        'command': f'{TERMINAL} &'
    },
    ('2', X.Mod1Mask | X.ControlMask): {
        'command': f'{EDITOR} &'
    },
    ('3', X.Mod1Mask | X.ControlMask):{
        'command': f'{BROWSER} &'
    },
    ('4', X.Mod1Mask | X.ControlMask):{
        'command': 'emacs -nw $HOME/memo.txt || emacs $HOME/memo.txt &'
    },
    ('6', X.Mod1Mask | X.ControlMask):{
        'command' : 'qutebrowser &'
    },
    ('7', X.Mod1Mask | X.ControlMask):{
        'command' : 'pkill zotero || zotero &'
    },
    ('8', X.Mod1Mask | X.ControlMask):{
        'command' : 'pkill mpg321 || mpg321 ~/Music/pianotoame &'
    },
    ('9', X.Mod1Mask | X.ControlMask): {    
        'command': 'pkill obsidian || obsidian &'
    },
    ('p', X.Mod1Mask | X.ControlMask): {
        'command': 'pkill xkbpointer && xset r || xkbpointer &' 
    },
    ('F11', X.Mod1Mask): {
        'command': 'mp4totxt &',
    },
    # --- モニタ内ウィンドウ遷移モード ---
    # Ctrl+Alt+0で「現在のモニタ内のウィンドウだけを遷移」するローカル選択モード
        'method': 'cb_toggle_monitor_local_selection'
    },

    # --- ウィンドウ操作系 ---
    # フォーカス・移動・分割・最大化
    ('i', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_focus_next_window',
        'arg': FORWARD
    },
    ('r', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_raise_window'
    },
    ('m', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_maximize_window',
        'arg': HORIZONTAL | VERTICAL
    },
    ('comma', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_maximize_window',
        'arg': VERTICAL
    },
    ('h', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_halve_window',
        'arg': LEFT
    },
    ('l', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_halve_window',
        'arg': RIGHT
    },
    ('j', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_halve_window',
        'arg': LOWER
    },
    ('k', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_halve_window',
        'arg': UPPER
    },
    ('n', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_move_window_to_next_monitor'
    },
    ('s', X.Mod1Mask | X.ControlMask):{
        'method': 'cb_swap_windows_bw_monitors'
    },
    ('z', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_destroy_window'
    },
    ('t', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_tile_windows'
    },
    ('BackSpace', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_set_always_top'
    },
    ('b', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_force_external_monitor'
    },
    ('5', X.Mod1Mask | X.ControlMask):{
        'method': 'toggle_xpymon_and_adjust_windows'
    },

    # --- 仮想スクリーン・ウィンドウ管理系 ---
    ('F1', X.Mod1Mask): {
        'method': 'cb_select_vscreen',
        'arg': 0
    },
    ('F2', X.Mod1Mask): {
        'method': 'cb_select_vscreen',
        'arg': 1
    },
    ('F3', X.Mod1Mask): {
        'method': 'cb_select_vscreen',
        'arg': 2
    },
    ('F4', X.Mod1Mask): {
        'method': 'cb_select_vscreen',
        'arg': 3
    },
    ('d', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_send_window_to_next_vscreen',
        'arg': FORWARD
    },
    ('a', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_send_window_to_next_vscreen',
        'arg': BACKWARD
    },
    ('Home', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_reconfigure_monitors',
        'arg': True
    },
    ('End', X.Mod1Mask | X.ControlMask): {
        'method': 'cb_reconfigure_monitors',
        'arg': False
    },
    ('Delete', X.Mod1Mask | X.ControlMask): {
        'function': 'restart'
    },

    # --- 音量・録画・メディア系 ---
    ('F6',  X.Mod1Mask): {
        'command': 'pactl set-sink-volume @DEFAULT_SINK@ -5%'
    },
    ('F7',  X.Mod1Mask): {
        'command': 'pactl set-sink-volume @DEFAULT_SINK@ +5%',
    },
    ('F5',  X.Mod1Mask): {
        'command': 'pactl set-sink-mute @DEFAULT_SINK@ toggle',
    },
    ('F12', X.Mod1Mask): {
        'method': 'cb_record_screen',
         'arg': 'current'
    },    
}

def debug(str):
    print(str, file=sys.stderr, flush=True)

# --- デバッグ用: 起動時の環境情報を出力 ---
def debug_env_info():
    debug('function: debug_env_info called')
    debug(f"[mosakuwm起動] UID={os.getuid()} USER={os.getenv('USER')} DISPLAY={os.getenv('DISPLAY')} SHELL={os.getenv('SHELL')}")
    debug(f"[mosakuwm起動] sys.argv={sys.argv}")
    debug(f"[mosakuwm起動] PWD={os.getcwd()}")
    debug(f"[mosakuwm起動] PATH={os.getenv('PATH')}")

# --- Emacs自動起動（既に起動していなければ） ---
def ensure_emacs_running():
    debug('function: ensure_emacs_running called')
    try:
        out = subprocess.getoutput('pgrep -x emacs')
        if not out.strip():
            debug('[mosakuwm] Emacsが起動していないため自動起動します')
            subprocess.Popen([EDITOR], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        else:
            debug('[mosakuwm] Emacsは既に起動しています')
    except Exception as e:
        debug(f'[mosakuwm] Emacs自動起動チェックで例外: {e}')

def restart():
    debug('function: restart called')
    debug(f'restrating {sys.argv[0]}')
    os.execvp(sys.argv[0], [sys.argv[0]])

class mosakuWM:
    """
    Xlibを用いたシンプルなタイル型ウィンドウマネージャ。
    - 複数モニタ・仮想スクリーン・ウィンドウ枠・自動タイル等に対応
    - XRandRイベントを監視し、外部ディスプレイ接続時に自動で拡張デスクトップ化
    注意: Xlibの低レベルAPIを直接扱うため、環境依存の挙動や制約がある
    """
    def __init__(self):
        # Xサーバーとの接続・初期化。各種管理用データ構造も初期化
        self.display = display.Display()
        self.screen = self.display.screen()
        self.colormap = self.screen.default_colormap
        self.keybinds = {}
        # --- ウィンドウ・モニタ管理用の主要変数 ---
        self.special_window = []  # 特殊枠ウィンドウ
        self.managed_windows = {}  # 管理対象ウィンドウ
        self.exposed_windows = []  # 表示中ウィンドウ
        self.coverdwindows = []    # 被覆ウィンドウ
        self.window_vscreen = {}   # 仮想スクリーン割当
        self.current_vscreen = 0
        self.frame_windows = {}    # 枠ウィンドウ
        self.framed_window = None # 枠付きウィンドウ
        self.is_selection_mode_enabled = False
        self.pressed_keys = set()
        self.last_dragged_time = time.time()
        # --- マルチモニタ・仮想スクリーン初期化 ---
        self.monitor_geometries = self.get_available_monitor_geometries()
        self.maxsize = self.get_screen_size()
        # --- xpymon表示状態の管理（create_selection_windowより前に初期化） ---
        self.xpymon_visible = False  # xpymon表示状態を管理
        # --- 追加: モニタ内ウィンドウ遷移用フラグとリスト ---
        self.is_monitor_local_selection = False
        self.local_monitor_windows = []
        # --- Xイベントのグラブ・初期ウィンドウ管理 ---
        self.catch_events()
        self.grab_keys()
        self.grab_buttons()
        self.create_frame_windows()
        self.create_selection_window()
        self.font = self.display.open_font(FONT)
        self.white_gc = self.selection_window.create_gc(font=self.font, foreground=self.screen.white_pixel)
        self.black_gc = self.selection_window.create_gc(font=self.font, foreground=self.screen.black_pixel)
        # --- 修飾キー名の管理 ---
        self.mod_string = [
            'shift', 'lock', 'control', 'mod1',
            'mod2', 'mod3', 'mod4', 'mod5']
        self.mod_mask_string = {
            X.ShiftMask: 'shift', X.LockMask: 'lock', X.ControlMask: 'control',
            X.Mod1Mask: 'mod1', X.Mod2Mask: 'mod2', X.Mod3Mask: 'mod3',
            X.Mod4Mask: 'mod4', X.Mod5Mask: 'mod5'}
        self.modmap = {}
        self.parse_xmodmap()
        # --- 既存ウィンドウの管理開始 ---
        for child in self.screen.root.query_tree().children:
            if child.get_attributes().map_state:
                self.manage_window(child)
        self.sort_exposed_windows()
        self.always_top = [None for _ in range(MAX_VSCREEN)]
        # --- XRandRイベント監視・自動拡張デスクトップ化 ---
        randr.select_input(self.screen.root, randr.RRScreenChangeNotifyMask)
        self.randr_event_type = self.display.extension_event._data['ScreenChangeNotify']
        EVENTS[self.randr_event_type] = 'handle_randr_screen_change'
        # --- ローカルsink名を起動時に記憶 ---
        self.local_sink_name = self.get_local_sink_name()
        # --- 一度でも現れた外部出力名を記憶 ---
        self.known_external_outputs = set()
        self.update_known_external_outputs()

    def update_known_external_outputs(self):
        debug('function: update_known_external_outputs called')
        # xrandr出力からDP-*, HDMI-*を全て記憶
        xrandr_out = subprocess.getoutput('xrandr')
        for line in xrandr_out.split('\n'):
            if any(prefix in line for prefix in ['DP-', 'HDMI-']):
                name = line.split()[0]
                if name != 'eDP-1':  # 内蔵は除外
                    self.known_external_outputs.add(name)

    def catch_events(self):
        debug('function: catch_events called')
        try:
            self.screen.root.change_attributes(
                event_mask = X.SubstructureRedirectMask |
                X.SubstructureNotifyMask |
                X.EnterWindowMask |
                X.LeaveWindowMask |
                X.FocusChangeMask)
            debug('[catch_events] SubstructureRedirectMask取得成功')
        except Exception as e:
            debug(f'[catch_events] SubstructureRedirectMask取得失敗: {e}')

    def grab_keys(self):
        debug('function: grab_keys called')
        for (key, modifier), rule in KEY_BINDS.items():
            keysym = XK.string_to_keysym(key)
            keycode = self.display.keysym_to_keycode(keysym)
            debug(f'[grab_keys] key={key} keysym={keysym} keycode={keycode} modifier={modifier} rule={rule}')
            if modifier is None:
                continue
            self.screen.root.grab_key(keycode, modifier, True,
                X.GrabModeAsync, X.GrabModeAsync)
            self.keybinds[(keycode, modifier)] = rule
            debug(f'[grab_keys] ({key}, {modifier}) grabbed as ({keycode}, {modifier})')

    def grab_buttons(self):
        debug('function: grab_buttons called')
        for button in [1, 3]:
            self.screen.root.grab_button(
                button, X.Mod1Mask, True,
                X.ButtonPressMask, X.GrabModeAsync,
                X.GrabModeAsync, X.NONE, X.NONE)

    def create_frame_windows(self):
        debug('function: create_frame_windows called')
        self.frame_pixel = self.colormap.alloc_named_color(FRAME_COLOR).pixel
        for side in ['left', 'right', 'upper', 'lower']:
            window = self.screen.root.create_window(
                0,0,16,16,0,
                self.screen.root_depth,
                X.InputOutput,
                background_pixel=self.frame_pixel,
                override_redirect=True)
            window.map()
            self.frame_windows[side] = window

    def draw_frame_windows(self):
        debug('function: draw_frame_windows called')
        if self.framed_window == None:
            return

        if self.framed_window in self.special_window:
            new_frame_pixel = self.colormap.alloc_named_color(FRAME_SPECIAL_COLOR).pixel
            for side in ['left', 'right', 'upper', 'lower']:
                self.frame_windows[side].change_attributes(background_pixel=new_frame_pixel)
                self.frame_windows[side].clear_area(0, 0, 0, 0, True) 
        else:
            new_frame_pixel = self.colormap.alloc_named_color(FRAME_COLOR).pixel
            for side in ['left', 'right', 'upper', 'lower']:
                self.frame_windows[side].change_attributes(background_pixel=new_frame_pixel)
                self.frame_windows[side].clear_area(0, 0, 0, 0, True) 
        geom = self.get_window_geometry(self.framed_window)
        if geom == None:
            return
        for side in ['left', 'right', 'upper', 'lower']:
            x, y, width, height = 0,0,0,0
            if side == 'left':
                x = geom.x
                y = geom.y
                width = FRAME_THICKNESS
                height = geom.height
            elif side == 'right':
                x = geom.x + geom.width - FRAME_THICKNESS
                y = geom.y
                width = FRAME_THICKNESS
                height = geom.height
            elif side == 'upper':
                x = geom.x
                y = geom.y
                width = geom.width
                height = FRAME_THICKNESS
            elif side == 'lower':
                x = geom.x
                y = geom.y + geom.height - FRAME_THICKNESS
                width = geom.width
                height = FRAME_THICKNESS
            self.frame_windows[side].configure(
                x=x, y=y, width=width, height=height, stack_mode=X.Above)
            self.frame_windows[side].map()

    def map_frame_windows(self):
        debug('function: map_frame_windows called')
        for side in ['left', 'right', 'upper', 'lower']:
            self.frame_windows[side].map()

    def unmap_frame_windows(self):
        debug('function: unmap_frame_windows called')
        for side in ['left', 'right', 'upper', 'lower']:
            self.frame_windows[side].unmap()

    def create_selection_window(self, monitor=1):
        debug('function: create_selection_window called')
        monitor = list(self.monitor_geometries.values())[monitor%len(self.monitor_geometries)]
        eff_monitor = self.get_effective_monitor_geometry(monitor)
        width = eff_monitor['width']//3
        height = 10
        x = eff_monitor['x']+eff_monitor['width']//3
        y = eff_monitor['y']+eff_monitor['height']//3
        self.selection_window = self.screen.root.create_window(
            x, y,
            width, height,
            0,
            self.screen.root_depth,
            X.InputOutput,
            background_pixel=self.screen.black_pixel,
            override_redirect=True)
        self.selection_window.change_attributes(backing_store=X.Always)

    def update_selection_window(self):
        debug('function: update_selection_window called')
        geom = self.get_window_geometry(self.selection_window)
        if geom == None:
            return
        self.selection_window.configure(
            x=geom.x,
            y=geom.y,
            width=geom.width,
            height=20*len(self.exposed_windows))
        self.selection_window.clear_area(0,0,geom.width,geom.height)
        idx = self.exposed_windows.index(self.framed_window)
        for i in range(len(self.exposed_windows)):
            win = self.exposed_windows[i]
            win_name = '{}: 0x{:x}'.format(self.get_window_class(win)[:50], win.id)
            chars = [c.encode() for c in list(win_name)]
            self.selection_window.poly_text(self.white_gc,20,20*(i+1)-5,chars)
        win_name = '{self.get_window_class(self.framed_window)[:50]}: 0x{:x}'\
            .format(self.get_window_class(self.framed_window)[:50], win.id)
        chars = [c.encode() for c in list(win_name)]
        self.selection_window.fill_rectangle(
            self.white_gc,0,20*idx,geom.width,20)
        self.selection_window.poly_text(
            self.black_gc,20,20*(idx+1)-5,chars)
        self.selection_window.configure(stack_mode=X.Above)

    def get_window_attributes(self, window):
        debug('function: get_window_attributes called')        
        try:
            # /usr/local/lib/python3.10/dist-packages/Xlib/xobject/drawble.py
            # /usr/local/lib/python3.10/dist-packages/Xlib/protocol/request.py
            return window.get_attributes()
        except:
            return None

    def get_window_class(self, window):
        debug('function: get_window_class called')
        try:
            cmd, cls = window.get_wm_class()
        except:
            return ''
        if cls is not None:
            return cls
        else:
            return ''

    def get_window_name(self, window):
        debug('function: get_window_name called')
        try:
            return f'id->0x{window.id:x}, name->{self.get_window_class(window)}'
        except:
            return ''

    def get_window_id(self, window):
        debug('function: get_window_id called')
        try:
            return window.id
        except:
            return None
            

    def manage_window(self, window):
        debug('function: manage_window called')
        """
        新規ウィンドウを管理対象に追加し、必要な属性・イベントマスクを設定する。
        - 既に管理済み・override_redirectなウィンドウは無視
        - 管理リストや仮想スクリーン割当も更新
        """
        attrs = self.get_window_attributes(window)
        if window in self.managed_windows.keys():
            return
        if attrs is None:
            return
        if attrs.override_redirect:
            return
        debug(f'debug: managed {self.get_window_name(window)}')
        self.managed_windows[window] = self.get_monitor_geometry_with_window(window)
        self.exposed_windows.append(window)
        self.window_vscreen[window] = self.current_vscreen
        window.map()
        window.change_attributes(
            event_mask=X.EnterWindowMask | X.LeaveWindowMask)

    def unmanage_window(self, window):
        debug('function: unmanage_window called')
        if window in self.managed_windows.keys():
            debug('unmanaged')
            self.managed_windows.pop(window)
        if window in self.exposed_windows:
            self.exposed_windows.remove(window)
        if self.always_top[self.current_vscreen] == window:
            self.always_top[self.current_vscreen] = None
            self.coverdwindows.clear()


    def sort_exposed_windows(self):
        debug('function: sort_exposed_windows called')
        def sort_key(window):
            geom = self.get_window_geometry(window)
            if geom is None:
                return 1<<31
            else:
                # この計算式により、ウィンドウはまずX座標に基づいて並べ替えられ、
                # X座標が同じ場合はY座標に基づいてさらに並べ替えられる
                return geom.x * self.maxsize['height'] + geom.y
        self.exposed_windows = sorted(self.exposed_windows, key=sort_key)

    def focus_window(self, window):
        debug('function: focus_window called')
        """
        指定ウィンドウにフォーカスを当て、スタック順序・枠描画も制御する。
        - exposed_windowsにないウィンドウは無視
        - 枠付きウィンドウのwarp_pointerも行う
        注意: stack_always_topやdraw_frame_windowsもここで呼ばれる
        """
        if window not in self.exposed_windows:
            return
        debug('debug: focused {}'.format(self.get_window_name(window)))
        window.set_input_focus(X.RevertToParent, 0)
        window.configure(stack_mode=X.Above)        
        self.framed_window = window
        self.stack_always_top()
        self.draw_frame_windows()

    def focus_next_window(self, window, direction=FORWARD):
        debug('function: focus_next_window called')
        # モニタ内遷移モード時はlocal_monitor_windowsを使う
        if self.is_monitor_local_selection and self.local_monitor_windows:
            target_windows = self.local_monitor_windows
        else:
            target_windows = self.exposed_windows
        if not target_windows:
            return
        if window in target_windows:
            idx = target_windows.index(window)
            if direction == FORWARD:
                nextidx = (idx+1)%len(target_windows)
                while target_windows[nextidx] in self.coverdwindows:                    
                    nextidx = (nextidx+1)%len(target_windows)                
                idx = nextidx
            else:
                nextidx = (idx-1)%len(target_windows)
                while target_windows[nextidx] in self.coverdwindows:                    
                    nextidx = (nextidx-1)%len(target_windows)                
                idx = nextidx                
            next_window = target_windows[idx]
        else:
            next_window = target_windows[0]
        self.focus_window(next_window)
        next_window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)

    def get_window_geometry(self, window):
        debug('function: get_window_geometry called')
        try:
            return window.get_geometry()
        except:
            return None

    def get_monitor_coverarea(self, wgeom, mgeom):
        debug('function: get_monitor_coverarea called')
        xmin = min(wgeom.x, mgeom['x'])
        xmax = max(wgeom.x + wgeom.width, mgeom['x'] + mgeom['width'])
        xsum = wgeom.width + mgeom['width']
        xcover = max(0, xsum - (xmax-xmin))
        ymin = min(wgeom.y, mgeom['y'])
        ymax = max(wgeom.y + wgeom.height, mgeom['y'] + mgeom['height'])
        ysum = wgeom.height + mgeom['height']
        ycover = max(0, ysum - (ymax-ymin))
        return xcover * ycover


    def get_monitor_geometry_with_window(self, window):
        debug('function: get_monitor_geometry_with_window called')
        """
        指定したウィンドウが「どの物理モニターに主に属しているか」を判定し、そのモニターの位置・サイズ情報（ジオメトリ）を返す。
        - ウィンドウが複数のモニターにまたがっている場合でも、「一番多く重なっているモニター」を自動で選ぶ。
        - 例えば「ウィンドウを次のモニターに移動」「最大化」など、ウィンドウの基準となるモニターを知りたいときに使う。
        """
        geom  = self.get_window_geometry(window)
        maxcoverage = 0
        maxmonitor = list(self.monitor_geometries.values())[0]
        for name, monitor in self.monitor_geometries.items():
            coverarea = self.get_monitor_coverarea(geom, monitor)
            coverage = coverarea / (monitor['width']*monitor['height'])
            normcoverage = coverarea * coverage
            if maxcoverage < normcoverage:
                maxcoverage = normcoverage
                maxmonitor = monitor
        return maxmonitor

    def get_effective_monitor_geometry(self, monitor):
        """
        xpymon表示中はy+8, height-8、非表示はそのまま返す
        """
        if self.xpymon_visible:
            return {
                'name': monitor['name'],
                'x': monitor['x'],
                'y': monitor['y'] + 8,
                'width': monitor['width'],
                'height': monitor['height'] - 8,
            }
        else:
            return monitor

    def toggle_xpymon_and_adjust_windows(self, event):
        debug('function: toggle_xpymon_and_adjust_windows called')
        if self.xpymon_visible:
            os.system(f'pkill xpymon')
            self.xpymon_visible = False
            # xpymon非表示時: y-8, height+8
            for window in self.managed_windows:
                geom = self.get_window_geometry(window)
                if geom is None:
                    continue
                # 既にy<=8なら0に戻す
                new_y = geom.y - 8 if geom.y >= 8 else 0
                new_height = geom.height + 8
                window.configure(x=geom.x, y=new_y, width=geom.width, height=new_height)
        else:
            os.system(f'xpymon &')
            self.xpymon_visible = True
            # xpymon表示時: y+8, height-8
            for window in self.managed_windows:
                geom = self.get_window_geometry(window)
                if geom is None:
                    continue
                new_y = geom.y + 8
                new_height = max(geom.height - 8, 1)  # 高さが1未満にならないように
                window.configure(x=geom.x, y=new_y, width=geom.width, height=new_height)
        self.draw_frame_windows()

    def get_screen_size(self):
        debug('function: get_screen_size called')
        lines = subprocess.getoutput('xrandr').split('\n')
        match = re.search(r'current (\d+) x (\d+)', lines[0])
        return {
            'width' : int(match.group(1)),
            'height' : int(match.group(2)),
        }

    def get_available_monitor_geometries(self):
        debug('function: get_available_monitor_geometries called')
        # ディスプレイに接続されたモニターの位置やサイズを取得するためのメソッド
        monitors = self.get_monitors_info()
        geometries = {}
        for name, monitor in monitors.items():
            if monitor['connected']:
                geom = monitor['geometry']
                if not geom:
                    debug(f'Monitor {name} is connected but not mapped.')
                    continue
                width, height, x, y = geom['width'], geom['height'], geom['x'], geom['y']
                geometries[name] = {
                    'name': name,
                    'width': width,
                    'height': height,
                    'x': x,
                    'y': y,
                }
        return geometries

    def get_monitors_info(self):
        debug('function: get_monitors_info called')
        lines = subprocess.getoutput('xrandr').split('\n')
        monitors = {}
        for line in lines[1:]:
            if 'connected' in line:
                name = line.split()[0]
                if ' connected' in line:
                    connected = True
                else:
                    connected = False
                try:
                    m = re.search(r'(\d+)x(\d+)\+(\d+)\+(\d+)', line)
                    width = int(m.group(1))
                    height = int(m.group(2))
                    x = int(m.group(3))
                    y = int(m.group(4))
                    geom = {
                        'width': width,
                        'height': height,
                        'x': x,
                        'y': y,
                    }
                except:
                    geom = None
                if 'primary' in line:
                    primary = True
                else:
                    primary = False
                monitors[name] = {
                    'connected': connected,
                    'geometry': geom,
                    'primary': primary,
                }
        return monitors

    def remap_monitors(self, remap):
        debug('function: remap_monitors called')
        monitors = self.get_monitors_info()
        leftmost = True
        for name, monitor in monitors.items():
            if monitor['connected']:
                if leftmost:
                    leftmost = False
                    os.system(f'xrandr --output {name} --auto')
                else:
                    os.system(f'xrandr --output {name} --auto --right-of {rightnext}')
                rightnext = name
            else:
                os.system(f'xrandr --output {name} --off')

    def reconfigure_monitors(self, remap):
        debug('function: reconfigure_monitors called')
        if remap:
            self.remap_monitors(remap)
        updated_geometries = self.get_available_monitor_geometries()
        if len(updated_geometries) == 0:
            debug('no monitor is connected')
            return
        basemonitor = list(updated_geometries.values())[0]
        for window in self.managed_windows.keys():
            src = self.managed_windows.get(window, None)
            if src is None:
                debug('source window is None')
                continue
            dst = updated_geometries.get(src['name'], None)
            if dst is None:
                self.move_window_to_monitor(window, basemonitor)
            else:
                self.move_window_to_monitor(window, dst)
        self.monitor_geometries = updated_geometries
        # monitor再構成後、全ウィンドウのmonitor割当を再計算
        for window in self.managed_windows.keys():
            self.maximize_window(window, HORIZONTAL | VERTICAL)

    def parse_xmodmap(self):
        debug('function: parse_xmodmap called')
        out = subprocess.getoutput('xmodmap')
        for modifier in self.mod_string:
            self.modmap[modifier] = []
            match = re.search(r'{} +(.+\(0x[0-9a-f]+\)(,  )?)+'.format(modifier), out)
            if match == None:
                continue
            keys = re.findall(r'([^?!,.]+ \(0x[0-9a-f]+\))', match.group(1))
            for k in keys:
                m = re.search(r'0x([0-9a-f]+)', k)
                value = int(m.group(0), 16)
                self.modmap[modifier].append(value)

    def maximize_window(self, window, mask):
        debug('function: maximize_window called')
        if window not in self.exposed_windows:
            debug('debug: at maximize_window window is not in exposed_windows')
            return
        monitor = self.managed_windows.get(window, None)
        if monitor is None:
            return
        eff_monitor = self.get_effective_monitor_geometry(monitor)
        geom = self.get_window_geometry(window)
        x = geom.x
        y = geom.y
        width = geom.width
        height = geom.height
        if mask & VERTICAL != 0:
            y = eff_monitor['y']
            height = eff_monitor['height']
        if mask & HORIZONTAL != 0:
            x = eff_monitor['x']
            width = eff_monitor['width']
        window.configure(
            x=x,
            y=y,
            width=width,
            height=height)

    def halve_window(self, window, args):
        debug('function: halve_window called')
        if window not in self.exposed_windows:
            return
        geom = self.get_window_geometry(window)
        if geom is None:
            return
        if args & (LEFT | RIGHT) != 0:
           if geom.width <= WINDOW_MIN_WIDTH:
               return
        if args & (UPPER | LOWER) != 0:
            if geom.height <= WINDOW_MIN_HEIGHT:
               return
        x, y, width, height = geom.x, geom.y, geom.width, geom.height
        px, py = 0, 0
        if args & (LEFT | RIGHT) != 0:
            width //= 2
        if args & (UPPER | LOWER) != 0:
            height //= 2
        if args & RIGHT != 0:
            x += width
            # px += width
        if args & LOWER != 0:
            y += height
            # py += height
        window.configure(
            x=x,
            y=y,
            width=width,
            height=height)
        self.managed_windows[window] = self.get_monitor_geometry_with_window(window)

    def move_window_to_monitor(self, window, dst):
        debug('function: move_window_to_monitor called')
        if window not in self.managed_windows.keys():
            return
        src = self.managed_windows.get(window, None)
        if src is None:
            return
        wgeom = self.get_window_geometry(window)
        if wgeom is None:
            return
        eff_dst = self.get_effective_monitor_geometry(dst)
        eff_src = self.get_effective_monitor_geometry(src)
        hratio = eff_dst['width']/eff_src['width']
        vratio = eff_dst['height']/eff_src['height']
        x,y,width,height = wgeom.x, wgeom.y, wgeom.width, wgeom.height
        xd = x - eff_src['x']
        yd = y - eff_src['y']
        x = int(xd * hratio) + eff_dst['x']
        y = int(yd * vratio) + eff_dst['y']
        width = int(width * hratio)
        height = int(height * vratio)
        window.configure(
            x=x,
            y=y,
            width=width,
            height=height)
        self.managed_windows[window] = dst

    def move_window_to_next_monitor(self, window):
        debug('function: move_window_to_next_monitor called')
        if window not in self.exposed_windows:
            return
        geom = self.get_window_geometry(window)
        if geom is None:
            return
        # src = self.get_monitor_geometry_with_window(window)
        src = self.managed_windows.get(window, None)
        if src is None:
            return
        srcidx = list(self.monitor_geometries.values()).index(src)
        dstidx = (srcidx+1)%len(self.monitor_geometries)
        dst = list(self.monitor_geometries.values())[dstidx]
        self.move_window_to_monitor(window, dst)

      

    def destroy_window(self, window):
        debug('function: destroy_window called')
        if window not in self.managed_windows.keys():
            return
        window.destroy()
        self.unmanage_window(window)
        self.focus_next_window(window)
        self.framed_window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)

    def capture_screen(self, window):
        debug('function: capture_screen called')
        if window is None:
            capture = '-window root'
        else:
            try:
                capture = f'-window {self.get_window_id(window)}'
            except:
                return
        now = datetime.datetime.now()
        date = '{}-{}-{}_{}:{}:{}.{}'.format(
            str(now.year).zfill(4),
            str(now.month).zfill(2),
            str(now.day).zfill(2),
            str(now.hour).zfill(2),
            str(now.minute).zfill(2),
            str(now.second).zfill(2),
            str(now.microsecond).zfill(6))
        os.system(f'import {capture} {SCREENSHOT_DIR}/capture{date}.png')
        
    def get_idle_sources(self):
        debug('function: get_idle_sources called')
        """
        PulseAudioの入力ソース一覧から、現在IDLE状態のモニターデバイス名を取得する。
        - 録画時に音声入力デバイス（例: monitor of built-in audio）を自動選択する用途で使う
        - IDLE状態のものだけをリストで返す
        """
        # パイプでコマンドの出力を取得
        result = subprocess.run(['pactl', 'list', 'sources', 'short'], stdout=subprocess.PIPE)

        # 出力を文字列に変換して行に分割
        output = result.stdout.decode('utf-8').strip().split('\n')

        idle_sources = []

        # 各行を処理
        for line in output:
            # 各列をスペースまたはタブで分割
            columns = line.split()
        
            # 第7列目（インデックス6）が 'idle' だったら、第2列目（インデックス1）を取得
            if len(columns) > 6 and columns[6] == 'IDLE':
                idle_sources.append(columns[1])

        return idle_sources

    def get_local_sink_name(self):
        debug('function: get_local_sink_name called')
        """
        pactl list short sinks の出力から一番最後のsink名を返す。
        - 状態やローカルsink判定は行わない
        """
        result = subprocess.run(['pactl', 'list', 'sinks', 'short'], stdout=subprocess.PIPE)
        output = result.stdout.decode('utf-8').strip().split('\n')
        if not output:
            return None
        # 最後の行のsink名（2列目）を返す
        last_line = output[-1]
        columns = last_line.split()
        if len(columns) > 1:
            return columns[1]
        return None

    def record_screen(self, window):
        """
        画面録画を開始・停止する。
        - 録画中でなければffmpegで画面＋音声を録画開始、再度呼ぶと録画停止
        - windowが指定されていればそのウィンドウ領域だけ録画、なければ全画面録画
        - PulseAudioのIDLEなモニターデバイスを自動選択
        注意: ffmpeg, pactl, PulseAudioが必要
        """
        global RECORDING_PROCESS
        debug('function: record_screen called')

        if RECORDING_PROCESS is None:
            # 録画開始
            capture = '-video_size 1920x1280 -framerate 60 -f x11grab -i :0.0'  # 全画面録画設定

            # ウィンドウ指定がある場合、そのウィンドウの位置とサイズを取得して録画範囲を限定
            if window is not None:
                try:
                    geom = self.get_window_geometry(window)
                    capture = f'-video_size {geom.width}x{geom.height} -framerate 60 -f x11grab -i :0.0+{geom.x},{geom.y}'
                except Exception as e:
                    debug(f'Failed to get window geometry: {e}')
                    # ウィンドウ情報が取得できなければ全画面録画にフォールバック

            # 保存先ディレクトリ（存在しなければ作成）
            SCREENSHOT_DIR = os.path.expanduser('~/Videos')
            os.makedirs(SCREENSHOT_DIR, exist_ok=True)

            # ファイル名に現在時刻を含める
            now = datetime.datetime.now()
            date = now.strftime('%Y-%m-%d_%H-%M-%S-%f')
            output_file = os.path.join(SCREENSHOT_DIR, f'{date}.mp4')

            # PulseAudioのモニターデバイスを指定
            # 下記のmonitor_deviceの値は、 `pactl list sources short`で確認したものを使用
            try:
                monitor_device = self.get_idle_sources()[0]
            except IndexError:
                return -1
            audio_input = f'-f pulse -i {monitor_device}'

            # ffmpegコマンドを構築
            cmd = f'ffmpeg {capture} {audio_input} -c:v libx264 -preset ultrafast -c:a aac "{output_file}"'
            # サブプロセスでffmpegを実行
            RECORDING_PROCESS = subprocess.Popen(cmd, shell=True, preexec_fn=os.setsid)

            debug(f'Started recording to {output_file}')
        else:
            # 録画停止（SIGINTシグナルを送信）
            debug('Stopping recording')
            os.killpg(os.getpgid(RECORDING_PROCESS.pid), signal.SIGINT)
            RECORDING_PROCESS.wait()
            RECORDING_PROCESS = None
            debug('Recording stopped')       
        

    def select_vscreen(self, num):
        debug('function: select_vscreen called')
        if num < 0:
            return
        if num > MAX_VSCREEN:
            return
        self.current_vscreen = num
        self.exposed_windows = []
        for window in self.managed_windows.keys():
            if self.window_vscreen[window] == num:
                window.map()
                self.exposed_windows.append(window)
            else:
                window.unmap()

    def send_window_to_next_vscreen(self, window, direction):
        debug('function: send_window_to_next_vscreen called')
        if window not in self.exposed_windows:
            return None
        idx = self.window_vscreen[window]
        if direction == FORWARD:
            nextidx = (idx+1) % MAX_VSCREEN
        else:
            nextidx = (idx-1) % MAX_VSCREEN            
        if self.always_top[idx] == window: 
            self.always_top[idx] = None
            self.always_top[nextidx] = window            
        self.window_vscreen[window] = nextidx
        return nextidx

    def get_tile_layout(self, tile_num):
        debug('function: get_tile_layout called')
        tmp = int(math.sqrt(tile_num))
        # (row, col)
        if tmp**2 == tile_num:
            return (tmp, tmp)
        if (tmp+1)*tmp >= tile_num:
            return (tmp, tmp+1)
        return (tmp+1, tmp+1)

    def tile_windows(self, window):
        debug('function: tile_windows called')
        monitor = self.managed_windows.get(window, None)
        if monitor is None:
            return
        eff_monitor = self.get_effective_monitor_geometry(monitor)
        target_windows = []
        for win in self.exposed_windows:
            if monitor == self.managed_windows.get(win, None):
                target_windows.append(win)
        def sort_key(window):
            return window.id
        target_windows.sort(key=sort_key)
        nrows, ncols = self.get_tile_layout(len(target_windows))
        offcuts_num = nrows*ncols - len(target_windows)
        eidx = None
        for i in range(len(target_windows)):
            if PRIORITY_WINDOW in self.get_window_class(target_windows[i]).lower():
                eidx = i
        if eidx is not None:
            target_windows[eidx], target_windows[ncols*(nrows-1)-1] = \
                target_windows[ncols*(nrows-1)-1], target_windows[eidx]
        for row in reversed(range(nrows)):
            for col in reversed(range(ncols)):
                if not target_windows:
                    break
                win = target_windows.pop(0)
                x = eff_monitor['x'] + eff_monitor['width']*col//ncols
                width = eff_monitor['width']//ncols
                if row == 1 and col < offcuts_num:
                    height = eff_monitor['height']*2//nrows
                    y = 0 + eff_monitor['y']
                else:
                    height = eff_monitor['height']//nrows
                    y = eff_monitor['y'] + eff_monitor['height']*row//nrows
                win.configure(x=x, y=y, width=width, height=height)
        window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)

    def set_window_to_stack_top(self, window):
        debug('function: set_window_to_stack_top called')
        if window not in self.exposed_windows:
            return
        idx = self.exposed_windows.index(window)
        self.exposed_windows.pop(idx)
        self.exposed_windows.insert(0, window)

    def stack_always_top(self):
        debug('function: stack_always_top called')
        window = self.always_top[self.current_vscreen]
        if window == None:
            return
        window.configure(stack_mode=X.Above)

    def cb_focus_next_window(self, event, args):
        """
        ウィンドウ選択モードの切り替えと、次のウィンドウへのフォーカス移動を行う。
        - selection modeが無効なら有効化し、キーボードグラブと枠移動を行う
        - 有効時は次のウィンドウにフォーカスを移す
        注意: selection modeの有効/無効や修飾キー管理に注意
        """
        debug('function: cb_focus_next_window called')
        window = self.framed_window
        if self.is_selection_mode_enabled:
            self.focus_next_window(self.framed_window, args)
        else:
            self.is_selection_mode_enabled = True
            # キーボードとマウス入力をmosakuwmが独占する（他アプリに渡さない）
            self.screen.root.grab_keyboard(True, X.GrabModeAsync, X.GrabModeAsync, X.CurrentTime)
            self.set_window_to_stack_top(window)
            if self.exposed_windows:
                self.focus_next_window(self.exposed_windows[0])
            # 押下中の修飾キーを記録
            modifier = event.state
            self.pressed_keys = set()
            for i in range(len(self.mod_string)+1):
                if 1<<i & modifier != 0:
                    self.pressed_keys = self.pressed_keys | {self.mod_mask_string[1<<i]}

    def cb_raise_window(self, event):
        debug('function: cb_raise_window called')
        window = event.child
        self.focus_window(window)
        self.set_window_to_stack_top(window)

    def cb_maximize_window(self, event, args):
        debug('function: cb_maximize_window called')
        window = self.framed_window
        try:
            self.maximize_window(window, args)
            # 焦点をあてたウィンドウの左端を基準に
            # (INIT_PTR_POS, INIT_PTR_POS)にポインターを配置
            window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)
            self.draw_frame_windows()
        except:
            return

    def cb_halve_window(self, event, args):
        debug('function: cb_halve_window called')
        window = self.framed_window
        try:
            self.halve_window(window, args)           
            window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)
            self.draw_frame_windows()
        except:
            return

    def cb_move_window_to_next_monitor(self, event):
        debug('function: cb_move_window_to_next_monitor called')
        window = self.framed_window
        try:
            self.move_window_to_next_monitor(window)
            window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)
            self.draw_frame_windows()
        except:
            return

    def cb_swap_windows_bw_monitors(self, event):
        debug('function: cb_swap_windows_bw_monitors called')
        for window in self.exposed_windows:
            self.move_window_to_next_monitor(window)
        window = self.framed_window 
        window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)
        self.focus_window(window)

    def cb_destroy_window(self, event):
        debug('function: cb_destroy_window called')
        window = self.framed_window
        try:
            self.destroy_window(window)
            # self.focus_next_window(window) 
            # self.framed_window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)
        except:
            return

    def cb_capture_screen(self, event, args):
        debug('function: cb_capture_screen called')
        window = self.framed_window
        if args == 'current':
            try:
                self.capture_screen(window)
            except:
                return
        else:
            self.capture_screen(None)

    def cb_record_screen(self, event, args):
        debug('function: cb_record_screen called')
        # window = self.framed_window
        if args == 'current':
            try:
                self.record_screen(None)
            except:
                return
        else:
            self.record_screen(None)

    def cb_select_vscreen(self, event, num):
        debug('function: cb_select_vscreen called')
        if self.current_vscreen == num:
            return
        self.select_vscreen(num)        
        if self.exposed_windows:
            self.sort_exposed_windows()
            self.focus_window(self.exposed_windows[0]) 
            self.framed_window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)
        else:
            self.framed_window = None
            self.unmap_frame_windows()

    def cb_send_window_to_next_vscreen(self, event, args):
        debug('function: cb_send_window_to_next_vscreen called')
        window = self.framed_window
        idx = self.send_window_to_next_vscreen(window, args)
        if idx is not None:
            self.select_vscreen(idx) 
            window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)
            self.focus_window(window)

    def cb_tile_windows(self, event):
        debug('function: cb_tile_windows called')
        window = self.framed_window
        self.tile_windows(window)
        self.focus_window(window)
        self.coverdwindows.clear()
        self.special_window.clear()

    def cb_reconfigure_monitors(self, event, remap):
        debug('function: cb_reconfigure_monitors called')
        self.reconfigure_monitors(remap)
        self.focus_window(self.framed_window)

    def cb_set_always_top(self, event):
        debug('function: cb_set_always_top called')
        """
        特定のウィンドウを仮想スクリーン上で常に最前面に固定・解除する。
        - 固定したウィンドウの短径領域に完全に含まれるウィンドウをcoverdwindowsに追加
        - 解除やtile時はcoverdwindows/special_windowをクリア
        注意: 複数ウィンドウ固定時の挙動やtileとの連携に注意
        """
        if self.always_top[self.current_vscreen] == self.framed_window:
            self.always_top[self.current_vscreen] = None
            # これだと 2つ以上 ウィンドウを固定したときの思った通りの動作をしない
            self.coverdwindows.clear()
            self.special_window = [element for element in self.special_window if element != self.framed_window]
            self.draw_frame_windows()
        else:
            self.always_top[self.current_vscreen] = self.framed_window
            self.coverd_check(self.framed_window)
            self.special_window.append(self.framed_window)
            self.draw_frame_windows()

    def coverd_check(self, parent_window):
        debug('function: coverd_check called')
        geom_parent_window = self.get_window_geometry(parent_window)
        for window in self.exposed_windows:
            IsCoverd = True
            if window == parent_window:
                continue
            else:
                geom = self.get_window_geometry(window)
                delta = 50
                if geom.x < geom_parent_window.x - delta:
                    IsCoverd = False
                if geom.y < geom_parent_window.y - delta:
                    IsCoverd = False
                if geom.x + geom.width > geom_parent_window.x + geom_parent_window.width + delta:
                    IsCoverd = False
                if geom.y + geom.height > geom_parent_window.y + geom_parent_window.height + delta:
                    IsCoverd = False
                if IsCoverd:
                    self.coverdwindows.append(window)
               

    def handle_motion_notify(self, event):
        debug('function: handle_motion_notify called')
        xd = event.root_x - self.start.root_x
        yd = event.root_y - self.start.root_y
        if self.start.child == X.NONE:
            return
        now = time.time()
        if now - self.last_dragged_time < DRAG_INTERVAL:
            return
        self.last_dragged_time = now
        if event.child in self.frame_windows.values():
            return
        if self.start.detail == 1:
            # move
            self.start.child.configure(
                x = self.start_geom.x + xd,
                y = self.start_geom.y + yd)
        elif self.start.detail == 3:
            # resize
            if self.start_geom.width+xd <= WINDOW_MIN_WIDTH:
                return
            if self.start_geom.height+yd <= WINDOW_MIN_HEIGHT:
                return
            self.start.child.configure(
                width = self.start_geom.width + xd,
                height = self.start_geom.height + yd)
        self.draw_frame_windows()

    def handle_button_press(self, event):
        debug('function: handle_button_press called')
        window = event.child
        if window in self.frame_windows.values():
            return
        if window not in self.managed_windows.keys():
            return
        self.screen.root.grab_pointer(True,
                                      X.PointerMotionMask |
                                      X.ButtonReleaseMask,
                                      X.GrabModeAsync,
                                      X.GrabModeAsync,
                                      X.NONE, X.NONE, 0)
        self.focus_window(window)
        self.start = event
        self.start_geom = self.get_window_geometry(window)

    def handle_button_release(self, event):
        debug('function: handle_button_release called')
        self.display.ungrab_pointer(0)
        self.managed_windows[event.child] = self.get_monitor_geometry_with_window(event.child)

    def handle_enter_notify(self, event):
        debug('function: handle_enter_notify called')
        window = event.window
        window.set_input_focus(X.RevertToParent, 0)
        
    # ウィンドウが表示されたときに、実行される。表示を通知するためのコマンド
    def handle_map_notify(self, event):
        debug('function: handle_map_notify called')
        self.manage_window(event.window)

    def handle_unmap_notify(self, event):
        debug('function: handle_unmap_notify called')
        if event.window in self.exposed_windows:
            self.unmanage_window(event.window)

    def handle_map_request(self, event):
        debug('function: handle_map_request called')
        self.manage_window(event.window)
        self.focus_window(event.window)
        self.framed_window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)

    def handle_destroy_notify(self, event):
        debug('function: handle_destroy_notify called')
        self.unmanage_window(event.window)
        # self.focus_next_window(event.window)
        # self.framed_window.warp_pointer(INIT_PTR_POS, INIT_PTR_POS)

    #  キーが押下されたときに、呼び出される。 
    def handle_key_press(self, event): 
        debug('function: handle_key_press called')
        keycode = event.detail
        modifier = event.state
        entry = (keycode, modifier)
        debug(f'[handle_key_press] keycode={keycode} modifier={modifier} entry={entry}')
        rule = self.keybinds.get(entry, None)
        if rule:
            debug(f'[handle_key_press] 対応アクション: {rule}')
            if 'method' in rule.keys():
                method = getattr(self, rule['method'], None)
                arg = rule.get('arg', None)
                if method:
                    if arg is not None:
                        method(event, arg)
                    else:
                        method(event)
            elif 'function' in rule.keys():
                function = globals().get(rule['function'], None)
                if function:
                    function()
            elif 'command' in rule.keys():
                debug(f'[handle_key_press] コマンド実行: {rule["command"]}')
                os.system(rule['command'])
        else:
            debug(f'[handle_key_press] 対応アクションなし: entry={entry}')

    def handle_key_release(self, event):
        debug('function: handle_key_release called')
        keycode = event.detail
        modgroup = None
        for mod, keys in self.modmap.items():
            if keycode in keys:
                modgroup = mod
                break
        if modgroup == None:
            return
        if modgroup in self.pressed_keys:
            # disable selection mode
            self.display.ungrab_keyboard(X.CurrentTime)
            self.is_selection_mode_enabled = False
            # self.selection_window.unmap()

    def handle_configure_request(self, event):
        debug('function: handle_configure_request called')
        window = event.window
        x = event.x
        y = event.y
        width = event.width
        height = event.height
        mask = event.value_mask
        if mask == 0b1111:
            window.configure(x=x, y=y, width=width, height=height)
        elif mask == 0b1100:
            window.configure(width=width, height=height)
        elif mask == 0b0011:
            window.configure(x=x, y=y)
        elif mask == 0b01000000:
            window.configure(event.stack_mode)
        if window in self.managed_windows.keys():
            self.managed_windows[window] = self.get_monitor_geometry_with_window(window)
            self.focus_window(window)
            
    def handle_randr_screen_change(self, event):
        debug('function: handle_randr_screen_change called')
        debug('XRandR event detected, reconfiguring monitors...')
        outputs = self.get_current_outputs()
        primary = None
        external = None
        for name, info in outputs.items():
            if info['primary'] and info['connected']:
                primary = name
            elif info['connected'] and ('DP-' in name or 'HDMI-' in name):
                external = name
        # 既に拡張済みなら何もしない
        if primary and external:
            subprocess.call(f'xrandr --output {external} --auto --right-of {primary}', shell=True)
        elif primary:
            subprocess.call(f'xrandr --output {primary} --auto', shell=True)
        # モニタ構成が変わった場合のみ再構成
        new_geometries = self.get_available_monitor_geometries()
        if new_geometries != self.monitor_geometries:
            self.reconfigure_monitors(False)
        # ローカルsink名を記憶済みのものに切り替え
        if self.local_sink_name:
            subprocess.call(f'pactl set-default-sink {self.local_sink_name}', shell=True)
        debug(f"[randr] monitor_geometries: {self.monitor_geometries}")
        debug(f"[randr] managed_windows: {list(self.managed_windows.keys())}")
        debug(f"[randr] exposed_windows: {self.exposed_windows}")

    def get_current_outputs(self):
        """
        現在のxrandr出力状態を辞書で返す
        { 'eDP-1': {'connected': True, 'primary': True, ...}, ... }
        """
        debug('function: get_current_outputs called')
        outputs = {}
        xrandr_out = subprocess.getoutput('xrandr')
        for line in xrandr_out.split('\n'):
            if ' connected' in line or ' disconnected' in line:
                name = line.split()[0]
                connected = ' connected' in line
                primary = ' primary' in line
                outputs[name] = {'connected': connected, 'primary': primary}
        return outputs

    def cb_force_external_monitor(self, event):
        debug('function: cb_force_external_monitor called')
        self.update_known_external_outputs()
        outputs = self.get_current_outputs()
        primary = None
        for name, info in outputs.items():
            if info['primary'] and info['connected']:
                primary = name
        # known_external_outputsのうち、現在disconnectedなものだけoff
        for ext in self.known_external_outputs:
            if ext == primary:
                continue
            if not outputs.get(ext, {}).get('connected', False):
                debug(f'[cb_force_external_monitor] running: xrandr --output {ext} --off')
                subprocess.call(f'xrandr --output {ext} --off', shell=True)
        # connectedな外部出力だけon
        for ext in self.known_external_outputs:
            if ext == primary:
                continue
            if outputs.get(ext, {}).get('connected', False):
                debug(f'[cb_force_external_monitor] running: xrandr --output {ext} --auto --right-of {primary}')
                subprocess.call(f'xrandr --output {ext} --auto --right-of {primary}', shell=True)
        # モニタ構成が変わった場合のみ再構成
        new_geometries = self.get_available_monitor_geometries()
        if new_geometries != self.monitor_geometries:
            self.reconfigure_monitors(False)
        # xpymon状態に応じて全ウィンドウを再配置（ウィンドウサイズ・位置は変更しない仕様に変更）
        # for window in self.managed_windows:
        #     geom = self.get_window_geometry(window)
        #     if geom is None:
        #         continue
        #     if self.xpymon_visible:
        #         new_y = geom.y + 8
        #         new_height = max(geom.height - 8, 1)
        #     else:
        #         new_y = geom.y - 8 if geom.y >= 8 else 0
        #         new_height = geom.height + 8
        #     window.configure(x=geom.x, y=new_y, width=geom.width, height=new_height)
        debug(f'[cb_force_external_monitor] monitor_geometries: {self.monitor_geometries}')

    def cb_toggle_monitor_local_selection(self, event):
        """
        モニタ内ウィンドウ遷移モード（Ctrl+Alt+0）
        - 有効化時: 現在フォーカス中ウィンドウが属するモニタ内のウィンドウのみを対象に遷移
        - 無効化時: 全ウィンドウを対象に通常の遷移に戻す
        - デュアル・マルチモニタ環境で、特定モニタ内だけでウィンドウを切り替えたい場合に便利
        例: 外部ディスプレイで作業中、他モニタのウィンドウに邪魔されずに切り替えたいとき等
        """
        if not self.is_monitor_local_selection:
            window = self.framed_window
            if window is None:
                return
            monitor = self.managed_windows.get(window, None)
            if monitor is None:
                return
            self.local_monitor_windows = [
                win for win in self.exposed_windows
                if self.managed_windows.get(win, None) == monitor
            ]
            if len(self.local_monitor_windows) > 1:
                self.is_monitor_local_selection = True
        else:
            self.is_monitor_local_selection = False
            self.local_monitor_windows = []

    def loop(self):
        debug('function: loop called')
        while True:
            event = self.display.next_event()
            if event.type in EVENTS:                
                handler = getattr(self, EVENTS[event.type], None)
                if handler:
                    handler(event)                    
                            

def main():
    debug('function: main called')
    debug_env_info()
    ensure_emacs_running()
    # Load per-user RC script (~/.mosakurc) if it exists
    try:
        with open(os.path.expanduser('~/.mosakurc'), 'r') as rc:
            exec(rc.read(), globals())
    except FileNotFoundError:
        pass
    # 外部ディスプレイ自動拡張
    xrandr_out = subprocess.getoutput('xrandr')
    primary = None
    external = None
    for line in xrandr_out.split('\n'):
        if ' connected primary' in line:
            primary = line.split()[0]
        elif ' connected' in line and 'primary' not in line:
            external = line.split()[0]
    if primary and external:
        subprocess.call(f'xrandr --output {external} --auto --right-of {primary}', shell=True)
    wm = mosakuWM()
    wm.reconfigure_monitors(False)
    for win in wm.managed_windows.keys():
        print(wm.get_window_name(win), file=sys.stderr)
        wm.loop()

if __name__ == '__main__':
    main() 